<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>WellcomeAI Widget</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <style>
    * { margin:0; padding:0; box-sizing:border-box; font-family:'Segoe UI','Roboto',sans-serif; }
    body { background: transparent; overflow: hidden; }
    .widget-wrapper { position: relative; width: 100%; height: 100%; }
    /* Кнопка-микрофон */
    #toggle-btn {
      position: fixed; bottom: 20px; right: 20px;
      width: 70px; height: 70px; border-radius: 50%;
      background: linear-gradient(135deg,#ffffff,#e1f5fe,#4a86e8);
      box-shadow: 0 5px 15px rgba(0,0,0,0.1);
      display: flex; align-items: center; justify-content: center;
      cursor: pointer; transition: all .3s ease; z-index: 9999;
    }
    #toggle-btn .mic-icon { font-size: 24px; color: #4a86e8; }

    /* Развернутое окно */
    #widget-container {
      display: none;
      position: fixed; bottom: 20px; right: 20px;
      width: 360px; height: 500px;
      background: white; border-radius: 15px;
      box-shadow: 0 5px 25px rgba(0,0,0,0.2);
      overflow: hidden; z-index: 9999;
      flex-direction: column;
    }
    #widget.expanded #widget-container {
      display: flex;
    }

    /* Кнопка закрытия */
    .close-widget {
      position: absolute; top: 15px; right: 15px;
      width: 30px; height: 30px; border: none;
      border-radius: 50%; background: rgba(255,255,255,0.8);
      display: flex; align-items: center; justify-content: center;
      cursor: pointer; box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      opacity: 0; transform: scale(0); transition: all .3s ease; z-index: 1001;
    }
    #widget.expanded .close-widget {
      opacity: 1; transform: scale(1);
    }
    .close-widget i { font-size: 18px; color: #555; }

    /* Лоадер */
    .loader-modal {
      position: absolute; top:0; left:0; width:100%; height:100%;
      background: rgba(255,255,255,0.7);
      display: flex; align-items:center; justify-content:center;
      opacity: 0; visibility: hidden; transition: all .3s; z-index:1000;
    }
    .loader-modal.active { opacity:1; visibility:visible; }
    .loader {
      width:48px; height:48px;
      border:4px solid rgba(74,134,232,0.3);
      border-radius:50%; border-top-color:#4a86e8;
      animation: spin 1s linear infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }

    /* Основной кружок внутри окна */
    .main-circle {
      width:200px; height:200px; border-radius:50%;
      background: linear-gradient(135deg,#ffffff,#e1f5fe,#4a86e8);
      box-shadow:0 10px 20px rgba(0,0,0,0.1);
      position:relative; overflow:hidden;
      display:flex; align-items:center; justify-content:center;
      transition: all .3s ease; margin:auto; margin-top:60px;
    }
    .main-circle::before {
      content: ''; position:absolute; width:140%; height:140%;
      background: linear-gradient(45deg,rgba(255,255,255,0.3),rgba(74,134,232,0.2));
      animation: wave 8s linear infinite; border-radius:40%;
    }
    @keyframes wave { 0%{transform:rotate(0deg);}100%{transform:rotate(360deg);} }
    .main-circle.listening {
      background: linear-gradient(135deg,#ffffff,#e3f2fd,#2196f3);
      box-shadow: 0 0 30px rgba(33,150,243,0.6);
    }
    .main-circle.listening::before {
      animation: wave 4s linear infinite;
      background: linear-gradient(45deg,rgba(255,255,255,0.5),rgba(33,150,243,0.3));
    }
    .main-circle.speaking {
      background: linear-gradient(135deg,#ffffff,#e8f5e9,#4caf50);
      box-shadow: 0 0 30px rgba(76,175,80,0.6);
    }
    .main-circle.speaking::before {
      animation: wave 3s linear infinite;
      background: linear-gradient(45deg,rgba(255,255,255,0.5),rgba(76,175,80,0.3));
    }
    .mic-icon { font-size:48px; color:#4a86e8; z-index:10; }
    .main-circle.listening .mic-icon { color:#2196f3; }
    .main-circle.speaking .mic-icon { color:#4caf50; }

    /* Визуализация звука */
    .audio-visualization {
      position:absolute; width:100%; max-width:200px; height:30px;
      bottom:10px; opacity:0.8;
    }
    .audio-bars {
      display:flex; align-items:flex-end; height:30px; gap:2px;
      width:100%; justify-content:center;
    }
    .audio-bar {
      width:3px; height:2px; background-color:#4a86e8;
      border-radius:1px; transition: height .1s ease;
    }

    /* Текстовое сообщение */
    .message-display {
      position:absolute; bottom:20px; left:50%;
      transform: translateX(-50%);
      background:white; padding:10px 15px; border-radius:8px;
      box-shadow:0 2px 10px rgba(0,0,0,0.1);
      max-width:80%; text-align:center; opacity:0;
      transition: all .3s;
    }
    .message-display.show { opacity:1; }
  </style>
</head>
<body>
  <div id="widget" class="widget-wrapper">
    <!-- Кнопка-микрофон до открытия -->
    <div id="toggle-btn" class="main-circle">
      <i class="fas fa-microphone mic-icon"></i>
    </div>
    <!-- Окно виджета -->
    <div id="widget-container" class="container">
      <button id="close-btn" class="close-widget">
        <i class="fas fa-times"></i>
      </button>
      <div id="loader-modal" class="loader-modal active">
        <div class="loader"></div>
      </div>
      <div class="main-circle" id="main-circle">
        <i class="fas fa-microphone mic-icon"></i>
      </div>
      <div class="audio-visualization" id="audio-visualization">
        <div class="audio-bars" id="audio-bars"></div>
      </div>
      <div class="message-display" id="message-display"></div>
    </div>
  </div>

  <script>
  (function(){
    const widget       = document.getElementById('widget');
    const toggleBtn    = document.getElementById('toggle-btn');
    const closeBtn     = document.getElementById('close-btn');
    const container    = document.getElementById('widget-container');
    const loaderModal  = document.getElementById('loader-modal');
    const mainCircle   = document.getElementById('main-circle');
    const audioBarsEl  = document.getElementById('audio-bars');
    const messageDisplay = document.getElementById('message-display');

    let initialized = false;
    let audioChunksBuffer   = [];
    let audioPlaybackQueue  = [];
    let isPlayingAudio      = false;
    let hasAudioData        = false;
    let audioDataStartTime  = 0;
    let minimumAudioLength  = 300;
    let reconnecting        = false;
    let isListening         = false;
    let websocket           = null;
    let audioContext        = null;
    let mediaStream         = null;
    let audioProcessor      = null;
    let isConnected         = false;
    const AUDIO_CONFIG = {
      silenceThreshold: 0.01,
      silenceDuration:  300,
      bufferCheckInterval: 50,
      soundDetectionThreshold: 0.02
    };
    let audioBufferTimeout = null;

    // Клик по микрофону: открыть и инициализировать
    toggleBtn.addEventListener('click', async () => {
      widget.classList.add('expanded');
      if (!initialized) {
        initialized = true;
        await initAudio();
        await connectWebSocket();
      }
    });

    // Клик по крестику: свернуть и приостановить аудио
    closeBtn.addEventListener('click', () => {
      widget.classList.remove('expanded');
      if (audioContext && audioContext.state === 'running') {
        audioContext.suspend();
        isListening = false;
      }
    });

    function log(msg, lvl='info'){ console.log(`[${lvl.toUpperCase()}] ${msg}`); }
    function showMessage(msg, dur=5000){
      messageDisplay.textContent = msg;
      messageDisplay.classList.add('show');
      setTimeout(() => messageDisplay.classList.remove('show'), dur);
    }

    function createAudioBars(count=20){
      audioBarsEl.innerHTML = '';
      for(let i=0;i<count;i++){
        const b = document.createElement('div');
        b.className = 'audio-bar';
        audioBarsEl.appendChild(b);
      }
    }
    createAudioBars();

    async function initAudio(){
      try {
        if (!navigator.mediaDevices?.getUserMedia) throw new Error('Нет доступа к микрофону');
        mediaStream = await navigator.mediaDevices.getUserMedia({
          audio: { echoCancellation:true, noiseSuppression:true, autoGainControl:true, sampleRate:24000 }
        });
        audioContext = new (window.AudioContext||window.webkitAudioContext)({ sampleRate:24000 });
        const src = audioContext.createMediaStreamSource(mediaStream);
        const bufSize = 2048;
        if (!audioContext.createScriptProcessor) throw new Error('ScriptProcessorNode не поддерживается');
        audioProcessor = audioContext.createScriptProcessor(bufSize,1,1);

        let isSilent=true, silenceStart=0, lastCommit=0, sentInSeg=false;
        audioProcessor.onaudioprocess = e => {
          if (isListening && websocket?.readyState===WebSocket.OPEN && !reconnecting) {
            const data = e.inputBuffer.getChannelData(0);
            let maxA=0;
            for(const v of data) maxA = Math.max(maxA, Math.abs(v));
            const hasSound = maxA > AUDIO_CONFIG.soundDetectionThreshold;
            updateAudioVisualization(data);

            // PCM16
            const pcm = new Int16Array(data.length);
            for(let i=0;i<data.length;i++) pcm[i] = Math.floor(data[i]*32767);
            try {
              websocket.send(JSON.stringify({
                type:'input_audio_buffer.append',
                event_id:`audio_${Date.now()}`,
                audio: arrayBufferToBase64(pcm.buffer)
              }));
              sentInSeg = true;
              if(!hasAudioData && hasSound){
                hasAudioData=true; audioDataStartTime=Date.now();
              }
            } catch(err){ log(`send audio error: ${err.message}`,'error'); }

            const now = Date.now();
            if(hasSound){
              isSilent=false; silenceStart=now;
              if(!mainCircle.classList.contains('listening')){
                mainCircle.classList.add('listening');
              }
              if(audioBufferTimeout) clearTimeout(audioBufferTimeout);
            } else if(!isSilent){
              if(now - silenceStart > AUDIO_CONFIG.silenceDuration){
                isSilent=true;
                if(now - lastCommit > 1000 && sentInSeg){
                  audioBufferTimeout = setTimeout(()=>{
                    if(isSilent && isListening && !reconnecting){
                      commitAudioBuffer();
                      lastCommit = Date.now();
                      sentInSeg = false;
                    }
                  },100);
                }
              }
            }
          }
        };
        src.connect(audioProcessor);
        audioProcessor.connect(audioContext.destination);
        log('Audio initialized');
        return true;
      } catch(err){
        log(`Audio init error: ${err.message}`,'error');
        showMessage('Ошибка микрофона');
        return false;
      }
    }

    function commitAudioBuffer(){
      if(!isListening||websocket?.readyState!==WebSocket.OPEN||reconnecting) return;
      if(!hasAudioData){ log('Empty buffer','warn'); return; }
      const length = Date.now() - audioDataStartTime;
      if(length < minimumAudioLength){
        return setTimeout(commitAudioBuffer, minimumAudioLength - length + 50);
      }
      sendCommitBuffer();
    }
    function sendCommitBuffer(){
      log('Commit buffer');
      mainCircle.classList.remove('listening');
      websocket.send(JSON.stringify({
        type:'input_audio_buffer.commit',
        event_id:`commit_${Date.now()}`
      }));
      hasAudioData=false; audioDataStartTime=0;
    }

    function arrayBufferToBase64(buf){
      const u = new Uint8Array(buf);
      let s='';
      for(const b of u) s+=String.fromCharCode(b);
      return btoa(s);
    }
    function base64ToArrayBuffer(b64){
      try {
        const bin = atob(b64), len=bin.length, u=new Uint8Array(len);
        for(let i=0;i<len;i++) u[i]=bin.charCodeAt(i);
        return u.buffer;
      } catch(e){ log(e.message,'error'); return new ArrayBuffer(0); }
    }

    function updateAudioVisualization(data){
      const bars = document.querySelectorAll('.audio-bar');
      const step = Math.floor(data.length / bars.length);
      for(let i=0;i<bars.length;i++){
        let sum=0;
        for(let j=0;j<step;j++){
          const v = data[i*step+j];
          if(v) sum += Math.abs(v);
        }
        const avg = sum/step;
        const h = 2 + Math.min(28, Math.floor(avg*100));
        bars[i].style.height = h + 'px';
      }
    }

    function createWavFromPcm(buf, sr=24000){
      const header = new ArrayBuffer(44), dv=new DataView(header);
      ['R','I','F','F'].forEach((c,i)=>dv.setUint8(i,c.charCodeAt(0)));
      dv.setUint32(4,36+buf.byteLength,true);
      ['W','A','V','E'].forEach((c,i)=>dv.setUint8(8+i,c.charCodeAt(0)));
      ['f','m','t',' '].forEach((c,i)=>dv.setUint8(12+i,c.charCodeAt(0)));
      dv.setUint32(16,16,true); dv.setUint16(20,1,true); dv.setUint16(22,1,true);
      dv.setUint32(24,sr,true); dv.setUint32(28,sr*2,true);
      dv.setUint16(32,2,true); dv.setUint16(34,16,true);
      ['d','a','t','a'].forEach((c,i)=>dv.setUint8(36+i,c.charCodeAt(0)));
      dv.setUint32(40,buf.byteLength,true);
      const wav = new ArrayBuffer(44+buf.byteLength), wv=new Uint8Array(wav);
      wv.set(new Uint8Array(header),0);
      wv.set(new Uint8Array(buf),44);
      return wav;
    }

    function addAudioToPlaybackQueue(b64){
      if(!b64) return;
      audioPlaybackQueue.push(b64);
      if(!isPlayingAudio) playNextAudio();
    }
    function playNextAudio(){
      if(audioPlaybackQueue.length===0){
        isPlayingAudio=false;
        mainCircle.classList.remove('speaking');
        return;
      }
      isPlayingAudio=true;
      mainCircle.classList.add('speaking');
      mainCircle.classList.remove('listening');
      const b64 = audioPlaybackQueue.shift();
      const buf = base64ToArrayBuffer(b64);
      if(buf.byteLength===0) return playNextAudio();
      const wavBuf = createWavFromPcm(buf), blob=new Blob([wavBuf],{type:'audio/wav'}), url=URL.createObjectURL(blob);
      const audio = new Audio(url);
      audio.oncanplaythrough = ()=>audio.play().catch(()=>playNextAudio());
      audio.onended = ()=>{ URL.revokeObjectURL(url); playNextAudio(); };
      audio.onerror = ()=>{ URL.revokeObjectURL(url); playNextAudio(); };
    }

    async function connectWebSocket(){
      loaderModal.classList.add('active');
      log('Connecting websocket...');
      const proto = location.protocol==='https:'?'wss:':'ws:',
            url = `${proto}//${location.host}/ws`;
      return new Promise(res=>{
        let timeout = setTimeout(()=>{
          log('Connection timeout','error');
          websocket.close();
          loaderModal.classList.remove('active');
          showMessage('Не удалось подключиться');
        },15000);
        websocket = new WebSocket(url);
        websocket.onopen = ()=>{
          clearTimeout(timeout);
          log('WebSocket open');
          isConnected = true;
          loaderModal.classList.remove('active');
          startListening();
          res(true);
        };
        websocket.onmessage = e=>{
          try {
            const d = JSON.parse(e.data);
            if(d.type==='response.text.delta' && d.delta) showMessage(d.delta,10000);
            else if(d.type==='response.audio.delta' && d.delta) audioChunksBuffer.push(d.delta);
            else if(d.type==='response.audio.done'){
              if(audioChunksBuffer.length){
                addAudioToPlaybackQueue(audioChunksBuffer.join(''));
                audioChunksBuffer=[];
              }
            }
            else if(d.type==='response.done'){
              setTimeout(()=>{ if(!isPlayingAudio&&!reconnecting) startListening(); },300);
            }
          } catch{}
        };
        websocket.onclose = ()=>{
          log('WebSocket closed');
          isConnected = false;
          isListening = false;
          reconnecting = false;
          showMessage('Отключено. Переподключение...');
          setTimeout(()=>connectWebSocket(),3000);
        };
        websocket.onerror = ()=>{ log('WebSocket error','error'); showMessage('Ошибка связи'); };
      });
    }

    async function startListening(){
      if(!isConnected||isPlayingAudio||reconnecting) return;
      isListening=true;
      log('Start listening');
      websocket.send(JSON.stringify({type:'input_audio_buffer.clear',event_id:`clear_${Date.now()}`}));
      if(!audioContext) await initAudio();
      else if(audioContext.state==='suspended') await audioContext.resume();
      hasAudioData = false;
      audioDataStartTime = 0;
      if(!isPlayingAudio && !reconnecting) mainCircle.classList.add('listening');
    }
  })();
  </script>
</body>
</html>
