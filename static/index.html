<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>welcomeAI - Голосовой помощник</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css">
  <style>
    :root {
      --bg-color: #050505;
      --primary-color: #00b3ff;
      --secondary-color: #2576ff;
      --text-color: #FFFFFF;
      --assistant-color: #3498db;
      --user-color: #9b59b6; 
      --panel-bg: rgba(10, 10, 10, 0.7);
      --surface-bg: rgba(20, 20, 20, 0.6);
    }
    
    [data-theme="light"] {
      --bg-color: #F5F5F7;
      --primary-color: #0088ff;
      --secondary-color: #0055ff;
      --text-color: #1D1D1F;
      --assistant-color: #0070e0;
      --user-color: #9933CC;
      --panel-bg: rgba(255, 255, 255, 0.8);
      --surface-bg: rgba(240, 240, 240, 0.9);
    }
    
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      transition: background-color 0.3s, color 0.3s;
    }
    
    body {
      font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background-color: var(--bg-color);
      color: var(--text-color);
      overflow: hidden;
      height: 100vh;
      width: 100vw;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }
    
    /* Градиентный фон */
    .bg-gradient {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: radial-gradient(circle at 50% 50%, var(--secondary-color) 0%, transparent 40%);
      opacity: 0.1;
      z-index: -1;
      animation: pulse-bg 15s ease infinite alternate;
    }
    
    @keyframes pulse-bg {
      0% { opacity: 0.05; transform: scale(1); }
      50% { opacity: 0.15; transform: scale(1.5); }
      100% { opacity: 0.05; transform: scale(1); }
    }
    
    /* Контейнер для всего содержимого */
    .container {
      position: relative;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }
    
    /* Логотип */
    .logo {
      position: absolute;
      top: 20px;
      left: 20px;
      font-size: 24px;
      font-weight: 600;
      color: var(--primary-color);
      letter-spacing: 0.5px;
      display: flex;
      align-items: center;
      gap: 8px;
      z-index: 10;
    }
    
    .logo i {
      font-size: 20px;
    }
    
    /* Центральная сфера */
    .sphere-container {
      position: relative;
      width: 280px;
      height: 280px;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10;
    }
    
    .sphere {
      width: 200px;
      height: 200px;
      border-radius: 50%;
      background: radial-gradient(circle at 30% 30%, var(--primary-color), var(--secondary-color));
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 
        0 0 60px rgba(0, 179, 255, 0.3),
        0 0 30px rgba(0, 179, 255, 0.2),
        0 0 10px rgba(0, 179, 255, 0.1);
      animation: ambient-glow 8s ease-in-out infinite alternate;
      cursor: pointer;
      transform-style: preserve-3d;
      transition: transform 0.3s ease, box-shadow 0.3s ease;
    }
    
    .sphere:hover {
      transform: scale(1.05);
      box-shadow: 
        0 0 80px rgba(0, 179, 255, 0.4),
        0 0 40px rgba(0, 179, 255, 0.3),
        0 0 15px rgba(0, 179, 255, 0.2);
    }
    
    @keyframes ambient-glow {
      0% { 
        box-shadow: 
          0 0 60px rgba(0, 179, 255, 0.3),
          0 0 30px rgba(0, 179, 255, 0.2),
          0 0 10px rgba(0, 179, 255, 0.1);
      }
      50% { 
        box-shadow: 
          0 0 70px rgba(0, 179, 255, 0.4),
          0 0 35px rgba(0, 179, 255, 0.3),
          0 0 12px rgba(0, 179, 255, 0.2);
      }
      100% { 
        box-shadow: 
          0 0 55px rgba(0, 179, 255, 0.3),
          0 0 25px rgba(0, 179, 255, 0.2),
          0 0 8px rgba(0, 179, 255, 0.1);
      }
    }
    
    .sphere-core {
      width: 180px;
      height: 180px;
      border-radius: 50%;
      background: radial-gradient(circle at 40% 40%, var(--bg-color) 0%, rgba(10, 10, 10, 0.9) 80%);
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      overflow: hidden;
      box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.5);
    }
    
    .sphere-icon {
      font-size: 50px;
      color: var(--primary-color);
      z-index: 1;
      opacity: 0.9;
      transition: opacity 0.3s, transform 0.3s;
    }
    
    /* Анимации сферы */
    
    /* Прослушивание */
    .sphere.listening {
      animation: 
        listening-pulse 1.5s infinite ease-in-out alternate,
        listening-glow 1.5s infinite ease-in-out alternate;
    }
    
    .sphere.listening .sphere-icon {
      animation: microphone-pulse 1.5s infinite ease-in-out alternate;
    }
    
    @keyframes listening-pulse {
      0% { transform: scale(1); }
      100% { transform: scale(1.05); }
    }
    
    @keyframes listening-glow {
      0% { 
        box-shadow: 
          0 0 60px rgba(0, 179, 255, 0.4),
          0 0 30px rgba(0, 179, 255, 0.3),
          0 0 10px rgba(0, 179, 255, 0.2);
      }
      100% { 
        box-shadow: 
          0 0 80px rgba(0, 179, 255, 0.6),
          0 0 40px rgba(0, 179, 255, 0.5),
          0 0 15px rgba(0, 179, 255, 0.4);
      }
    }
    
    @keyframes microphone-pulse {
      0% { transform: scale(1); opacity: 0.8; }
      100% { transform: scale(1.15); opacity: 1; }
    }
    
    /* Обработка */
    .sphere.processing {
      animation: 
        processing-pulse 2s infinite cubic-bezier(0.4, 0, 0.6, 1),
        processing-glow 2s infinite cubic-bezier(0.4, 0, 0.6, 1);
    }
    
    .sphere.processing .sphere-icon {
      animation: spin 2s infinite linear;
    }
    
    @keyframes processing-pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.03); }
    }
    
    @keyframes processing-glow {
      0%, 100% { 
        box-shadow: 
          0 0 70px rgba(0, 179, 255, 0.4),
          0 0 35px rgba(0, 179, 255, 0.3),
          0 0 12px rgba(0, 179, 255, 0.2);
      }
      50% { 
        box-shadow: 
          0 0 90px rgba(0, 179, 255, 0.5),
          0 0 45px rgba(0, 179, 255, 0.4),
          0 0 15px rgba(0, 179, 255, 0.3);
      }
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    /* Анимация при ответе */
    .sphere.speaking {
      animation: 
        speaking-pulse 1s infinite ease-in-out alternate,
        speaking-glow 1s infinite ease-in-out alternate,
        slight-float 5s infinite ease-in-out alternate;
    }
    
    .sphere.speaking .sphere-core {
      animation: core-pulse 1s infinite ease-in-out alternate;
    }
    
    .sphere.speaking .sphere-icon {
      animation: icon-wave 1s infinite ease-in-out alternate;
    }
    
    @keyframes speaking-pulse {
      0% { transform: scale(1); }
      100% { transform: scale(1.08); }
    }
    
    @keyframes speaking-glow {
      0% { 
        box-shadow: 
          0 0 70px rgba(0, 179, 255, 0.5),
          0 0 35px rgba(0, 179, 255, 0.4),
          0 0 12px rgba(0, 179, 255, 0.3);
      }
      100% { 
        box-shadow: 
          0 0 100px rgba(0, 179, 255, 0.7),
          0 0 50px rgba(0, 179, 255, 0.6),
          0 0 20px rgba(0, 179, 255, 0.5);
      }
    }
    
    @keyframes core-pulse {
      0% { transform: scale(1); }
      100% { transform: scale(0.97); }
    }
    
    @keyframes icon-wave {
      0% { transform: scale(1); opacity: 0.8; }
      100% { transform: scale(1.1); opacity: 1; }
    }
    
    @keyframes slight-float {
      0% { transform: translateY(0) scale(1); }
      100% { transform: translateY(-3px) scale(1.08); }
    }
    
    /* Волны вокруг сферы */
    .sphere-waves {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 300px;
      height: 300px;
      pointer-events: none;
    }
    
    .wave {
      position: absolute;
      border: 2px solid var(--primary-color);
      width: 100%;
      height: 100%;
      border-radius: 50%;
      opacity: 0;
      animation: wave 4s infinite linear;
    }
    
    .sphere.listening .wave {
      opacity: 0.1;
      border-color: var(--primary-color);
    }
    
    .sphere.speaking .wave {
      opacity: 0.2;
      border-color: var(--secondary-color);
      animation: wave 2.5s infinite linear;
    }
    
    .wave:nth-child(2) {
      animation-delay: 1s;
    }
    
    .wave:nth-child(3) {
      animation-delay: 2s;
    }
    
    @keyframes wave {
      0% {
        transform: scale(0.2);
        opacity: 0.7;
      }
      100% {
        transform: scale(1.2);
        opacity: 0;
      }
    }
    
    /* Визуализация аудио */
    .audio-visualizer {
      position: absolute;
      bottom: -50px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      align-items: flex-end;
      justify-content: center;
      height: 40px;
      width: 220px;
      gap: 3px;
    }
    
    .audio-bar {
      width: 3px;
      height: 3px;
      background-color: var(--primary-color);
      border-radius: 3px;
      transition: height 0.1s ease;
    }
    
    /* Эффект свечения для сферы */
    .glow-effect {
      position: absolute;
      width: 200px;
      height: 200px;
      border-radius: 50%;
      background: radial-gradient(circle at center, var(--primary-color) 0%, transparent 70%);
      opacity: 0.2;
      filter: blur(20px);
      animation: glow-breathing 8s infinite ease-in-out alternate;
    }
    
    @keyframes glow-breathing {
      0% { opacity: 0.1; transform: scale(1); filter: blur(20px); }
      50% { opacity: 0.3; transform: scale(1.5); filter: blur(30px); }
      100% { opacity: 0.1; transform: scale(1); filter: blur(20px); }
    }
    
    /* Частицы внутри сферы */
    .particles {
      position: absolute;
      width: 100%;
      height: 100%;
      overflow: hidden;
      border-radius: 50%;
    }
    
    .particle {
      position: absolute;
      width: 4px;
      height: 4px;
      background-color: var(--primary-color);
      border-radius: 50%;
      opacity: 0.5;
    }
    
    /* Сообщения */
    .message-display {
      position: absolute;
      bottom: 10%;
      left: 50%;
      transform: translateX(-50%);
      max-width: 90%;
      width: 500px;
      text-align: center;
      padding: 15px;
      border-radius: 10px;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      background-color: var(--panel-bg);
      box-shadow: 0 5px 20px rgba(0, 0, 0, 0.2);
      opacity: 0;
      transition: opacity 0.5s, transform 0.5s;
      z-index: 5;
      pointer-events: none;
    }
    
    .message-display.visible {
      opacity: 1;
      transform: translateX(-50%) translateY(0);
    }
    
    .message-text {
      font-size: 16px;
      line-height: 1.5;
      color: var(--text-color);
    }
    
    /* Транскрипция */
    .transcript {
      position: absolute;
      top: 10%;
      left: 50%;
      transform: translateX(-50%);
      max-width: 90%;
      width: 500px;
      text-align: center;
      padding: 15px;
      font-style: italic;
      color: var(--text-color);
      opacity: 0.8;
      min-height: 24px;
      transition: opacity 0.3s;
    }
    
    .transcript:empty {
      opacity: 0;
    }
    
    /* Статусное сообщение */
    .status-message {
      position: absolute;
      bottom: 25px;
      left: 50%;
      transform: translateX(-50%);
      text-align: center;
      font-size: 14px;
      color: var(--text-color);
      opacity: 0.6;
      transition: opacity 0.3s;
    }
    
    /* Настройки */
    .settings-toggle {
      position: absolute;
      top: 20px;
      right: 20px;
      font-size: 22px;
      color: var(--text-color);
      opacity: 0.7;
      cursor: pointer;
      z-index: 10;
      transition: opacity 0.3s;
    }
    
    .settings-toggle:hover {
      opacity: 1;
    }
    
    .settings-panel {
      position: absolute;
      top: 60px;
      right: 20px;
      background-color: var(--panel-bg);
      padding: 15px;
      border-radius: 10px;
      width: 250px;
      z-index: 10;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      box-shadow: 0 5px 20px rgba(0, 0, 0, 0.2);
      opacity: 0;
      transform: translateY(-10px);
      pointer-events: none;
      transition: opacity 0.3s, transform 0.3s;
    }
    
    .settings-panel.visible {
      opacity: 1;
      transform: translateY(0);
      pointer-events: all;
    }
    
    .settings-section {
      margin-bottom: 15px;
    }
    
    .settings-section-title {
      font-size: 16px;
      margin-bottom: 10px;
      color: var(--primary-color);
    }
    
    .settings-option {
      margin-bottom: 10px;
    }
    
    .settings-label {
      display: block;
      margin-bottom: 5px;
      font-size: 14px;
    }
    
    .settings-select {
      width: 100%;
      padding: 8px 10px;
      border-radius: 5px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      background: rgba(0, 0, 0, 0.2);
      color: var(--text-color);
      font-size: 14px;
    }
    
    /* Модальное окно загрузки */
    .modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 2000;
    }
    
    .modal-content {
      background-color: var(--panel-bg);
      padding: 30px;
      border-radius: 20px;
      max-width: 500px;
      width: 90%;
      text-align: center;
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
      animation: modalFadeIn 0.4s forwards;
    }
    
    @keyframes modalFadeIn {
      from { opacity: 0; transform: translateY(-20px); }
      to { opacity: 1; transform: translateY(0); }
    }
    
    .modal h2 {
      color: var(--primary-color);
      margin-bottom: 20px;
      font-size: 24px;
      font-weight: 600;
    }
    
    .modal p {
      margin-bottom: 20px;
      line-height: 1.6;
      font-size: 16px;
    }
    
    .spinner {
      display: inline-block;
      width: 50px;
      height: 50px;
      border: 3px solid rgba(255, 255, 255, 0.2);
      border-radius: 50%;
      border-top-color: var(--primary-color);
      animation: spin 1s linear infinite;
      margin-bottom: 20px;
    }
    
    /* Отладочная панель */
    .debug-panel {
      position: fixed;
      bottom: -300px;
      left: 0;
      width: 100%;
      height: 300px;
      background: rgba(0, 0, 0, 0.9);
      z-index: 1000;
      transition: bottom 0.3s ease;
      padding: 10px;
      color: #0f0;
      font-family: monospace;
      font-size: 12px;
    }
    
    .debug-panel.open {
      bottom: 0;
    }
    
    .debug-header {
      display: flex;
      justify-content: space-between;
      padding: 5px;
      border-bottom: 1px solid #333;
      margin-bottom: 10px;
    }
    
    .debug-title {
      font-weight: bold;
    }
    
    .debug-close {
      cursor: pointer;
    }
    
    .debug-log {
      height: 250px;
      overflow-y: auto;
      padding: 5px;
    }
    
    .log-entry {
      margin-bottom: 3px;
      line-height: 1.3;
    }
    
    .log-info { color: #58a6ff; }
    .log-error { color: #f85149; }
    .log-warn { color: #d29922; }
    .log-debug { color: #8b949e; }
    
    /* Адаптивность */
    @media (max-width: 768px) {
      .sphere {
        width: 180px;
        height: 180px;
      }
      
      .sphere-core {
        width: 160px;
        height: 160px;
      }
      
      .sphere-icon {
        font-size: 40px;
      }
    }
    
    @media (max-width: 480px) {
      .sphere {
        width: 150px;
        height: 150px;
      }
      
      .sphere-core {
        width: 130px;
        height: 130px;
      }
      
      .sphere-icon {
        font-size: 32px;
      }
      
      .message-display,
      .transcript {
        width: 90%;
        padding: 10px;
      }
      
      .message-text {
        font-size: 14px;
      }
    }
  </style>
</head>
<body>
  <!-- Градиентный фон -->
  <div class="bg-gradient"></div>
  
  <!-- Основной контейнер -->
  <div class="container">
    <!-- Логотип -->
    <div class="logo">
      <i class="fas fa-atom"></i>
      welcomeAI
    </div>
    
    <!-- Настройки -->
    <div class="settings-toggle" id="settings-toggle">
      <i class="fas fa-cog"></i>
    </div>
    
    <div class="settings-panel" id="settings-panel">
      <div class="settings-section">
        <div class="settings-section-title">Голос</div>
        <div class="settings-option">
          <select id="voice-selector" class="settings-select">
            <option value="alloy">Alloy (Стандартный)</option>
            <option value="echo">Echo (Эхо)</option>
            <option value="fable">Fable (Сказочный)</option>
            <option value="onyx">Onyx (Глубокий)</option>
            <option value="nova">Nova (Женский)</option>
            <option value="shimmer">Shimmer (Мерцающий)</option>
          </select>
        </div>
      </div>
      
      <div class="settings-section">
        <div class="settings-section-title">Режим прослушивания</div>
        <div class="settings-option">
          <select id="listening-mode" class="settings-select">
            <option value="manual">Ручной (нажатием на сферу)</option>
            <option value="continuous">Постоянный (всегда активен)</option>
            <option value="vad">Авто (определение речи)</option>
          </select>
        </div>
      </div>
    </div>
    
    <!-- Область транскрипции -->
    <div class="transcript" id="transcript"></div>
    
    <!-- Центральная сфера -->
    <div class="sphere-container">
      <div class="glow-effect"></div>
      <div class="sphere" id="main-sphere">
        <div class="sphere-core">
          <i class="fas fa-microphone sphere-icon"></i>
          <div class="particles" id="particles"></div>
        </div>
        <div class="sphere-waves">
          <div class="wave"></div>
          <div class="wave"></div>
          <div class="wave"></div>
        </div>
      </div>
      <div class="audio-visualizer" id="audio-visualizer">
        <!-- Аудио бары будут добавлены скриптом -->
      </div>
    </div>
    
    <!-- Отображение сообщения -->
    <div class="message-display" id="message-display">
      <div class="message-text" id="message-text"></div>
    </div>
    
    <!-- Статусное сообщение -->
    <div class="status-message" id="status-message">
      Нажмите на сферу, чтобы активировать помощника
    </div>
  </div>
  
  <!-- Модальное окно загрузки -->
  <div id="loading-modal" class="modal">
    <div class="modal-content">
      <div class="spinner"></div>
      <h2>Инициализация</h2>
      <p>Подключение к нейросети...</p>
      <div id="loading-status">Подождите...</div>
    </div>
  </div>
  
  <!-- Отладочная панель -->
  <div class="debug-panel" id="debug-panel">
    <div class="debug-header">
      <div class="debug-title">Отладка</div>
      <div class="debug-close" id="debug-close">✕</div>
    </div>
    <div class="debug-log" id="debug-log"></div>
  </div>

  <script>
    // Конфигурация и состояние
    const config = {
      debug: true,             // Включить отладку 
      listeningMode: 'manual', // manual, continuous, vad
      voice: 'alloy',          // Голос ассистента
      vadTimeout: 2000,        // Таймаут для определения окончания речи (мс)
      maxMessageTime: 5000,    // Время отображения сообщения (мс)
      audioSampleRate: 24000,  // Частота дискретизации аудио
      particleCount: 10        // Количество частиц в сфере
    };
    
    // Элементы UI
    const elements = {
      sphere: document.getElementById('main-sphere'),
      audioVisualizer: document.getElementById('audio-visualizer'),
      transcript: document.getElementById('transcript'),
      messageDisplay: document.getElementById('message-display'),
      messageText: document.getElementById('message-text'),
      statusMessage: document.getElementById('status-message'),
      loadingModal: document.getElementById('loading-modal'),
      loadingStatus: document.getElementById('loading-status'),
      debugPanel: document.getElementById('debug-panel'),
      debugLog: document.getElementById('debug-log'),
      settingsPanel: document.getElementById('settings-panel'),
      settingsToggle: document.getElementById('settings-toggle'),
      voiceSelector: document.getElementById('voice-selector'),
      listeningMode: document.getElementById('listening-mode'),
      debugClose: document.getElementById('debug-close'),
      particles: document.getElementById('particles')
    };
    
    // Стейт приложения
    const state = {
      isConnected: false,
      isListening: false,
      isProcessing: false,
      isSpeaking: false,
      websocket: null,
      audioContext: null,
      mediaStream: null,
      audioProcessor: null,
      vadTimer: null,
      messageTimer: null,
      currentResponseText: "",
      audioChunks: [],
      shouldReconnect: true,
      particlesRef: []
    };
    
    // Создаем частицы внутри сферы
    function createParticles() {
      elements.particles.innerHTML = '';
      state.particlesRef = [];
      
      for (let i = 0; i < config.particleCount; i++) {
        const particle = document.createElement('div');
        particle.className = 'particle';
        
        // Случайные начальные позиции
        const x = Math.random() * 100;
        const y = Math.random() * 100;
        
        particle.style.left = `${x}%`;
        particle.style.top = `${y}%`;
        particle.style.opacity = Math.random() * 0.7 + 0.1;
        
        // Сохраняем начальные координаты
        state.particlesRef.push({
          element: particle,
          x, y,
          speedX: (Math.random() - 0.5) * 0.3,
          speedY: (Math.random() - 0.5) * 0.3,
          size: Math.random() * 3 + 1
        });
        
        elements.particles.appendChild(particle);
      }
    }
    
    // Анимация частиц
    function animateParticles() {
      state.particlesRef.forEach(particle => {
        // Обновляем позиции
        particle.x += particle.speedX;
        particle.y += particle.speedY;
        
        // Отражение от краев
        if (particle.x <= 0 || particle.x >= 100) {
          particle.speedX *= -1;
        }
        if (particle.y <= 0 || particle.y >= 100) {
          particle.speedY *= -1;
        }
        
        // Применяем новые позиции
        particle.element.style.left = `${particle.x}%`;
        particle.element.style.top = `${particle.y}%`;
        
        // Изменяем размер и скорость при слушании и ответе
        if (state.isListening) {
          particle.speedX *= 1.001;
          particle.speedY *= 1.001;
          particle.element.style.width = `${particle.size * 1.5}px`;
          particle.element.style.height = `${particle.size * 1.5}px`;
        } else if (state.isSpeaking) {
          particle.speedX *= 1.002;
          particle.speedY *= 1.002;
          particle.element.style.width = `${particle.size * 2}px`;
          particle.element.style.height = `${particle.size * 2}px`;
        } else if (state.isProcessing) {
          // Сделать их более хаотичными при обработке
          particle.speedX += (Math.random() - 0.5) * 0.05;
          particle.speedY += (Math.random() - 0.5) * 0.05;
          particle.element.style.width = `${particle.size * 1.2}px`;
          particle.element.style.height = `${particle.size * 1.2}px`;
        } else {
          // Возвращаем к нормальному состоянию
          particle.speedX *= 0.99;
          particle.speedY *= 0.99;
          particle.element.style.width = `${particle.size}px`;
          particle.element.style.height = `${particle.size}px`;
        }
        
        // Ограничиваем скорость
        const maxSpeed = 0.5;
        const minSpeed = 0.05;
        particle.speedX = Math.max(Math.min(particle.speedX, maxSpeed), -maxSpeed);
        particle.speedY = Math.max(Math.min(particle.speedY, maxSpeed), -maxSpeed);
        
        // Если частица почти остановилась, добавляем немного случайного движения
        if (Math.abs(particle.speedX) < minSpeed && Math.abs(particle.speedY) < minSpeed) {
          particle.speedX += (Math.random() - 0.5) * 0.1;
          particle.speedY += (Math.random() - 0.5) * 0.1;
        }
      });
      
      requestAnimationFrame(animateParticles);
    }
    
    // Инициализация визуализатора аудио
    function initAudioVisualizer() {
      elements.audioVisualizer.innerHTML = '';
      for (let i = 0; i < 40; i++) {
        const bar = document.createElement('div');
        bar.className = 'audio-bar';
        elements.audioVisualizer.appendChild(bar);
      }
    }
    initAudioVisualizer();
    
    // Управление отладочными сообщениями
    function log(message, level = 'info') {
      const timestamp = new Date().toLocaleTimeString();
      console.log(`[${level.toUpperCase()}] ${message}`);
      
      if (config.debug) {
        const logEntry = document.createElement('div');
        logEntry.className = `log-entry log-${level}`;
        logEntry.textContent = `[${timestamp}] ${message}`;
        elements.debugLog.appendChild(logEntry);
        elements.debugLog.scrollTop = elements.debugLog.scrollHeight;
      }
      
      // Обновляем статус загрузки, если это информационное сообщение
      if (level === 'info' && elements.loadingModal.style.display !== 'none') {
        elements.loadingStatus.textContent = message;
      }
    }
    
    // Показать сообщение
    function showMessage(text, duration = config.maxMessageTime) {
      // Очищаем предыдущий таймер, если он есть
      if (state.messageTimer) {
        clearTimeout(state.messageTimer);
      }
      
      elements.messageText.textContent = text;
      elements.messageDisplay.classList.add('visible');
      
      // Скрываем сообщение через заданное время
      state.messageTimer = setTimeout(() => {
        elements.messageDisplay.classList.remove('visible');
      }, duration);
    }
    
    // Инициализация аудио
    async function initAudio() {
      try {
        log("Запрос разрешения на доступ к микрофону...");
        
        // Проверяем поддержку getUserMedia
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
          throw new Error("Ваш браузер не поддерживает доступ к микрофону");
        }
        
        // Запрашиваем доступ к микрофону
        state.mediaStream = await navigator.mediaDevices.getUserMedia({ 
          audio: {
            echoCancellation: true,
            noiseSuppression: true,
            autoGainControl: true,
            sampleRate: config.audioSampleRate
          } 
        });
        
        log("Доступ к микрофону получен");
        
        // Создаем AudioContext с нужной частотой дискретизации
        state.audioContext = new (window.AudioContext || window.webkitAudioContext)({ 
          sampleRate: config.audioSampleRate 
        });
        
        log(`AudioContext создан с частотой ${state.audioContext.sampleRate} Гц`);
        
        // Создаем обработчик аудиопотока
        const streamSource = state.audioContext.createMediaStreamSource(state.mediaStream);
        
        // Выбираем размер буфера
        const bufferSize = 4096;
        
        // Проверяем, доступен ли ScriptProcessorNode
        if (state.audioContext.createScriptProcessor) {
          state.audioProcessor = state.audioContext.createScriptProcessor(bufferSize, 1, 1);
          log("Создан ScriptProcessorNode для обработки аудио");
        } else {
          throw new Error("Ваш браузер не поддерживает ScriptProcessorNode");
        }
        
        // Обработчик аудио
        state.audioProcessor.onaudioprocess = handleAudioProcess;
        
        // Подключаем обработчик
        streamSource.connect(state.audioProcessor);
        state.audioProcessor.connect(state.audioContext.destination);
        
        log("Аудио инициализировано успешно");
        return true;
      } catch (error) {
        log(`Ошибка инициализации аудио: ${error.message}`, "error");
        elements.statusMessage.textContent = "Ошибка доступа к микрофону";
        return false;
      }
    }
    
    // Обработка аудио с микрофона
    function handleAudioProcess(e) {
      if ((state.isListening || config.listeningMode === 'continuous') && 
          state.websocket && 
          state.websocket.readyState === WebSocket.OPEN && 
          !state.isProcessing && 
          !state.isSpeaking) {
            
        // Получаем данные с микрофона
        const inputData = e.inputBuffer.getChannelData(0);
        
        // Проверяем, есть ли звук
        let hasSound = false;
        let maxAmplitude = 0;
        
        for (let i = 0; i < inputData.length; i++) {
          const absValue = Math.abs(inputData[i]);
          maxAmplitude = Math.max(maxAmplitude, absValue);
          if (absValue > 0.01) { // Порог обнаружения звука
            hasSound = true;
            break;
          }
        }
        
        // Обновляем визуализацию в любом случае
        updateAudioVisualization(inputData);
        
        // Если режим VAD и обнаружен звук, сбрасываем таймер
        if (config.listeningMode === 'vad' && hasSound && state.isListening) {
          resetVadTimer();
        }
        
        // Если обнаружен звук или мы в режиме непрерывного захвата
        if (hasSound || config.listeningMode === 'continuous') {
          // Преобразуем float32 в int16
          const pcm16Data = new Int16Array(inputData.length);
          for (let i = 0; i < inputData.length; i++) {
            pcm16Data[i] = Math.max(-32768, Math.min(32767, Math.floor(inputData[i] * 32767)));
          }
          
          // Отправляем данные через WebSocket
          try {
            const message = JSON.stringify({
              type: "input_audio_buffer.append",
              event_id: `audio_${Date.now()}`,
              audio: arrayBufferToBase64(pcm16Data.buffer)
            });
            
            state.websocket.send(message);
          } catch (error) {
            log(`Ошибка отправки аудио: ${error.message}`, "error");
          }
          
          // Если режим VAD и обнаружена речь, начинаем слушать если еще не слушаем
          if (config.listeningMode === 'vad' && hasSound && !state.isListening) {
            startListening();
          }
        }
      }
    }
    
    // Сброс VAD таймера
    function resetVadTimer() {
      if (state.vadTimer) {
        clearTimeout(state.vadTimer);
      }
      
      state.vadTimer = setTimeout(() => {
        if (state.isListening && config.listeningMode === 'vad') {
          log("VAD: Обнаружена пауза в речи", "info");
          stopListening();
        }
      }, config.vadTimeout);
    }
    
    // Преобразование ArrayBuffer в Base64
    function arrayBufferToBase64(buffer) {
      const bytes = new Uint8Array(buffer);
      let binary = '';
      for (let i = 0; i < bytes.byteLength; i++) {
        binary += String.fromCharCode(bytes[i]);
      }
      return btoa(binary);
    }
    
    // Преобразование Base64 в ArrayBuffer
    function base64ToArrayBuffer(base64) {
      try {
        const binaryString = atob(base64);
        const bytes = new Uint8Array(binaryString.length);
        for (let i = 0; i < binaryString.length; i++) {
          bytes[i] = binaryString.charCodeAt(i);
        }
        return bytes.buffer;
      } catch (e) {
        log(`Ошибка при декодировании base64: ${e.message}`, "error");
        return new ArrayBuffer(0);
      }
    }
    
    // Обновление визуализации аудио
    function updateAudioVisualization(audioData) {
      const bars = elements.audioVisualizer.querySelectorAll('.audio-bar');
      const step = Math.floor(audioData.length / bars.length);
      
      for (let i = 0; i < bars.length; i++) {
        let sum = 0;
        for (let j = 0; j < step; j++) {
          const index = i * step + j;
          if (index < audioData.length) {
            sum += Math.abs(audioData[index]);
          }
        }
        const average = sum / step;
        
        // Нормализуем значение для высоты полосы (от 3px до 40px)
        const height = 3 + Math.min(35, Math.floor(average * 150));
        bars[i].style.height = `${height}px`;
      }
    }
    
    // Сброс визуализации аудио
    function resetAudioVisualization() {
      const bars = elements.audioVisualizer.querySelectorAll('.audio-bar');
      bars.forEach(bar => {
        bar.style.height = '3px';
      });
    }
    
    // Создаём простой WAV из PCM данных
    function createWavFromPcm(pcmBuffer, sampleRate = 24000) {
      // Создаём заголовок WAV
      const wavHeader = new ArrayBuffer(44);
      const view = new DataView(wavHeader);
      
      // "RIFF" chunk descriptor
      view.setUint8(0, 'R'.charCodeAt(0));
      view.setUint8(1, 'I'.charCodeAt(0));
      view.setUint8(2, 'F'.charCodeAt(0));
      view.setUint8(3, 'F'.charCodeAt(0));
      
      view.setUint32(4, 36 + pcmBuffer.byteLength, true); // Размер всего файла - 8
      
      // "WAVE" формат
      view.setUint8(8, 'W'.charCodeAt(0));
      view.setUint8(9, 'A'.charCodeAt(0));
      view.setUint8(10, 'V'.charCodeAt(0));
      view.setUint8(11, 'E'.charCodeAt(0));
      
      // "fmt " субчанк
      view.setUint8(12, 'f'.charCodeAt(0));
      view.setUint8(13, 'm'.charCodeAt(0));
      view.setUint8(14, 't'.charCodeAt(0));
      view.setUint8(15, ' '.charCodeAt(0));
      
      view.setUint32(16, 16, true); // Размер fmt субчанка
      view.setUint16(20, 1, true);  // Формат аудио (1 = PCM)
      view.setUint16(22, 1, true);  // Число каналов (1 = моно)
      view.setUint32(24, sampleRate, true); // Частота дискретизации
      view.setUint32(28, sampleRate * 2, true); // Байт в секунду (SampleRate * NumChannels * BitsPerSample/8)
      view.setUint16(32, 2, true);  // Байт на сэмпл (NumChannels * BitsPerSample/8)
      view.setUint16(34, 16, true); // Бит на сэмпл
      
      // "data" субчанк
      view.setUint8(36, 'd'.charCodeAt(0));
      view.setUint8(37, 'a'.charCodeAt(0));
      view.setUint8(38, 't'.charCodeAt(0));
      view.setUint8(39, 'a'.charCodeAt(0));
      
      view.setUint32(40, pcmBuffer.byteLength, true); // Размер данных
      
      // Объединяем заголовок и PCM данные
      const wavBuffer = new ArrayBuffer(wavHeader.byteLength + pcmBuffer.byteLength);
      const wavBytes = new Uint8Array(wavBuffer);
      
      wavBytes.set(new Uint8Array(wavHeader), 0);
      wavBytes.set(new Uint8Array(pcmBuffer), wavHeader.byteLength);
      
      return wavBuffer;
    }
    
    // Воспроизведение аудио из Base64
    function playAudio(audioBase64) {
      try {
        // Проверяем непустую строку
        if (!audioBase64 || typeof audioBase64 !== 'string') {
          log("Получены пустые аудио данные", "warn");
          return;
        }
        
        // Декодируем Base64 в ArrayBuffer
        const audioData = base64ToArrayBuffer(audioBase64);
        
        // Проверяем размер данных
        if (audioData.byteLength === 0) {
          log("Аудио данные имеют нулевую длину", "warn");
          return;
        }
        
        log(`Получено ${audioData.byteLength} байт аудио данных`);
        
        // Активируем анимацию при воспроизведении
        state.isSpeaking = true;
        elements.sphere.classList.add('speaking');
        
        // Конвертируем PCM16 в WAV для воспроизведения
        const wavBuffer = createWavFromPcm(audioData);
        const blob = new Blob([wavBuffer], { type: 'audio/wav' });
        const audioUrl = URL.createObjectURL(blob);
        
        // Воспроизводим звук
        const audio = new Audio(audioUrl);
        audio.onerror = function(e) {
          log(`Ошибка воспроизведения аудио: ${e.target.error?.message || 'Неизвестная ошибка'}`, "error");
          state.isSpeaking = false;
          elements.sphere.classList.remove('speaking');
        };
        
        audio.oncanplaythrough = function() {
          log(`Готов к воспроизведению аудио: ${audio.duration.toFixed(2)} секунд`);
          audio.play().catch(err => {
            log(`Ошибка при воспроизведении: ${err.message}`, "error");
            state.isSpeaking = false;
            elements.sphere.classList.remove('speaking');
          });
        };
        
        // Освобождаем ресурсы и отключаем анимацию после воспроизведения
        audio.onended = function() {
          URL.revokeObjectURL(audioUrl);
          state.isSpeaking = false;
          elements.sphere.classList.remove('speaking');
          
          // Если в режиме постоянного прослушивания, активируем его снова
          if (config.listeningMode === 'continuous' && !state.isProcessing) {
            setTimeout(() => {
              state.isListening = true;
              elements.sphere.classList.add('listening');
              elements.statusMessage.textContent = "Слушаю вас...";
            }, 500);
          }
        };
      } catch (error) {
        log(`Ошибка воспроизведения аудио: ${error.message}`, "error");
        state.isSpeaking = false;
        elements.sphere.classList.remove('speaking');
      }
    }
    
    // Подключение к WebSocket серверу
    async function connectWebSocket() {
      return new Promise((resolve, reject) => {
        try {
          elements.loadingModal.style.display = 'flex';
          elements.statusMessage.textContent = "Подключение...";
          log("Подключение к WebSocket серверу...");
          
          // Используем WebSocket-соединение с нашим сервером
          const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
          const wsUrl = `${protocol}//${window.location.host}/ws`;
          log(`WebSocket URL: ${wsUrl}`);
          
          // Создаем новое WebSocket соединение
          state.websocket = new WebSocket(wsUrl);
          
          // Устанавливаем таймаут на открытие соединения
          const connectionTimeout = setTimeout(() => {
            log("Превышено время ожидания соединения WebSocket", "error");
            state.websocket.close();
            reject(new Error("Таймаут соединения"));
          }, 15000);
          
          state.websocket.onopen = function() {
            clearTimeout(connectionTimeout);
            log("WebSocket соединение установлено");
            elements.statusMessage.textContent = "Готово";
            state.isConnected = true;
            elements.loadingModal.style.display = 'none';
            showMessage("Привет! Я готов помочь вам. Задайте вопрос или нажмите на сферу для активации голосового ввода.", 6000);
            
            // Отправляем обновление настроек с выбранным голосом
            updateVoice(config.voice);
            
            // Если режим постоянного прослушивания, сразу начинаем
            if (config.listeningMode === 'continuous') {
              elements.sphere.classList.add('listening');
              elements.statusMessage.textContent = "Слушаю вас...";
              state.isListening = true;
            }
            
            resolve(true);
          };
          
          state.websocket.onmessage = function(event) {
            handleWebSocketMessage(event.data);
          };
          
          state.websocket.onclose = function(event) {
            log(`WebSocket соединение закрыто: код ${event.code}, причина: ${event.reason || 'не указана'}`, event.wasClean ? "info" : "error");
            elements.statusMessage.textContent = `Соединение закрыто`;
            elements.sphere.classList.remove('listening');
            elements.sphere.classList.remove('processing');
            elements.sphere.classList.remove('speaking');
            state.isConnected = false;
            state.isListening = false;
            
            // Пытаемся переподключиться, если соединение было разорвано не чисто и флаг shouldReconnect активен
            if (!event.wasClean && state.shouldReconnect) {
              log(`Попытка переподключения через 3 секунды...`, "warn");
              
              setTimeout(() => {
                connectWebSocket().catch(err => {
                  log(`Ошибка при переподключении: ${err.message}`, "error");
                });
              }, 3000);
            }
            
            reject(new Error(`Соединение закрыто: ${event.reason || 'Неизвестная причина'}`));
          };
          
          state.websocket.onerror = function(error) {
            log(`WebSocket ошибка: ${error.message || 'Неизвестная ошибка'}`, "error");
            elements.statusMessage.textContent = "Ошибка соединения";
            state.isConnected = false;
            reject(error);
          };
        } catch (error) {
          log(`Ошибка при установке WebSocket соединения: ${error.message}`, "error");
          reject(error);
        }
      });
    }
    
    // Обработка сообщений от сервера
    function handleWebSocketMessage(data) {
      try {
        // Если данные в бинарном формате, преобразуем их в текст
        if (data instanceof Blob) {
          const reader = new FileReader();
          reader.onload = function() {
            const text = reader.result;
            try {
              const json = JSON.parse(text);
              processServerEvent(json);
            } catch (e) {
              log(`Ошибка парсинга JSON из бинарных данных: ${e.message}`, "error");
            }
          };
          reader.readAsText(data);
        } else {
          try {
            const json = typeof data === 'string' ? JSON.parse(data) : data;
            processServerEvent(json);
          } catch (e) {
            log(`Ошибка парсинга JSON из текстовых данных: ${e.message}`, "error");
            log(`Данные: ${typeof data === 'string' ? data.substring(0, 100) : 'не строка'}`, "debug");
          }
        }
      } catch (error) {
        log(`Ошибка обработки сообщения: ${error.message}`, "error");
      }
    }
    
    // Обработка событий от сервера
    function processServerEvent(event) {
      if (!event || !event.type) {
        log("Получено некорректное событие без типа", "warn");
        return;
      }
      
      log(`Событие от сервера: ${event.type}`, "debug");
      
      switch (event.type) {
        case "error":
          log(`Ошибка от сервера: ${event.error ? event.error.message : 'Неизвестная ошибка'}`, "error");
          elements.statusMessage.textContent = `Ошибка: ${event.error ? event.error.message : 'Неизвестная ошибка'}`;
          showMessage(`Произошла ошибка: ${event.error ? event.error.message : 'Неизвестная ошибка'}`, 3000);
          break;
          
        case "conversation.item.input_audio_transcription.delta":
        case "conversation.item.input_audio_transcription.completed":
          // Обновляем транскрипцию распознанной речи пользователя
          if (event.transcript || event.delta) {
            const transcript = event.transcript || event.delta;
            elements.transcript.textContent = transcript;
            log(`Транскрипция: ${transcript}`, "info");
            
            if (event.type === "conversation.item.input_audio_transcription.completed") {
              showMessage(transcript, 5000);
              elements.transcript.textContent = "";
            }
          }
          break;
          
        case "response.text.delta":
          // Обрабатываем текстовый ответ по частям
          if (event.delta) {
            state.currentResponseText += event.delta;
            showMessage(state.currentResponseText);
          }
          break;
          
        case "response.text.done":
          // Текстовый ответ завершен
          if (event.text) {
            state.currentResponseText = event.text;
            log(`Текстовый ответ завершен: ${state.currentResponseText.substring(0, 50)}...`, "info");
            showMessage(state.currentResponseText);
          }
          break;
          
        case "response.audio.delta":
          // Обрабатываем аудиоответ по частям
          if (event.delta) {
            state.audioChunks.push(event.delta);
          }
          break;
          
        case "response.audio.done":
          // Аудиоответ завершен, воспроизводим его
          if (state.audioChunks.length > 0) {
            log(`Аудиоответ завершен, ${state.audioChunks.length} фрагментов`, "info");
            const fullAudio = state.audioChunks.join('');
            playAudio(fullAudio);
            state.audioChunks = [];
          }
          break;
          
        // Обработка дополнительных типов событий
        case "response.audio_transcript.delta":
        case "response.audio_transcript.done":
        case "response.content_part.added":
        case "response.content_part.done":
        case "response.output_item.added":
        case "response.output_item.done":
          // Просто логируем эти события
          log(`Получено событие ${event.type}`, "debug");
          break;
          
        case "response.done":
          // Ответ полностью завершен
          log("Ответ полностью завершен", "info");
          state.isProcessing = false;
          elements.sphere.classList.remove('processing');
          
          // Сбрасываем состояние
          state.currentResponseText = "";
          resetAudioVisualization();
          
          // Если режим непрерывного прослушивания, продолжаем слушать
          if (config.listeningMode === 'continuous' && !state.isSpeaking) {
            elements.statusMessage.textContent = "Слушаю вас...";
            elements.sphere.classList.add('listening');
            state.isListening = true;
          } else if (!state.isSpeaking) {
            elements.statusMessage.textContent = "Готово";
            elements.sphere.classList.remove('listening');
            state.isListening = false;
          }
          break;
          
        case "session.created":
          log("Сессия создана на сервере", "info");
          break;
          
        case "session.updated":
          log("Сессия обновлена", "info");
          break;
          
        case "input_audio_buffer.committed":
          log("Аудиобуфер отправлен", "info");
          break;
          
        case "input_audio_buffer.cleared":
          log("Аудиобуфер очищен", "info");
          break;
          
        case "input_audio_buffer.speech_started":
          log("Обнаружена речь", "info");
          break;
          
        case "input_audio_buffer.speech_stopped":
          log("Речь завершена", "info");
          break;
          
        default:
          log(`Неизвестный тип события: ${event.type}`, "debug");
      }
    }
    
    // Начало записи голоса
    function startListening() {
      if (!state.isConnected || state.isProcessing || state.isSpeaking) {
        log("Невозможно начать запись: " + (!state.isConnected ? "не подключено" : state.isProcessing ? "идет обработка" : "идет воспроизведение"), "warn");
        return;
      }
      
      state.isListening = true;
      elements.sphere.classList.add('listening');
      elements.statusMessage.textContent = "Слушаю вас...";
      elements.transcript.textContent = "";
      log("Начало записи голоса", "info");
      
      // Отправляем команду для очистки буфера ввода
      state.websocket.send(JSON.stringify({
        type: "input_audio_buffer.clear",
        event_id: `clear_${Date.now()}`
      }));
      
      // Возобновляем AudioContext если он был приостановлен
      if (state.audioContext && state.audioContext.state === 'suspended') {
        state.audioContext.resume();
      }
      
      // Если VAD режим, запускаем таймер
      if (config.listeningMode === 'vad') {
        resetVadTimer();
      }
    }
    
    // Окончание записи голоса
    function stopListening() {
      if (!state.isListening) return;
      
      state.isListening = false;
      elements.sphere.classList.remove('listening');
      elements.sphere.classList.add('processing');
      elements.statusMessage.textContent = "Обработка...";
      log("Завершение записи голоса", "info");
      
      // Отправляем команду для завершения записи
      state.websocket.send(JSON.stringify({
        type: "input_audio_buffer.commit",
        event_id: `commit_${Date.now()}`
      }));
      
      // Отправляем команду для создания ответа
      state.websocket.send(JSON.stringify({
        type: "response.create",
        event_id: `response_${Date.now()}`,
        response: {}
      }));
      
      state.isProcessing = true;
      resetAudioVisualization();
      
      // Очищаем VAD таймер если он есть
      if (state.vadTimer) {
        clearTimeout(state.vadTimer);
        state.vadTimer = null;
      }
    }
    
    // Переключение режима прослушивания
    function toggleListening() {
      if (config.listeningMode !== 'manual') return;
      
      if (state.isListening) {
        stopListening();
      } else if (!state.isProcessing && !state.isSpeaking) {
        startListening();
      }
    }
    
    // Обновление голоса ассистента
    function updateVoice(voiceId) {
      if (!state.isConnected || !state.websocket) return;
      
      log(`Смена голоса на ${voiceId}`, "info");
      
      // Отправляем обновление сессии
      state.websocket.send(JSON.stringify({
        type: "session.update",
        event_id: `voice_${Date.now()}`,
        session: {
          voice: voiceId
        }
      }));
      
      // Обновляем конфигурацию
      config.voice = voiceId;
    }
    
    // Переключение режима прослушивания
    function setListeningMode(mode) {
      log(`Переключение режима прослушивания на ${mode}`, "info");
      
      // Останавливаем текущее прослушивание
      if (state.isListening) {
        stopListening();
      }
      
      config.listeningMode = mode;
      
      // Обновляем интерфейс и поведение
      switch (mode) {
        case 'continuous':
          elements.statusMessage.textContent = "Постоянное прослушивание активно";
          if (state.isConnected && !state.isProcessing && !state.isSpeaking) {
            state.isListening = true;
            elements.sphere.classList.add('listening');
          }
          break;
          
        case 'vad':
          elements.statusMessage.textContent = "Автоматическое определение речи активно";
          break;
          
        case 'manual':
        default:
          elements.statusMessage.textContent = "Нажмите на сферу для активации микрофона";
          elements.sphere.classList.remove('listening');
          state.isListening = false;
          break;
      }
    }
    
    // Инициализация всего приложения
    async function init() {
      try {
        log("Инициализация приложения", "info");
        
        // Создаем частицы и запускаем анимацию
        createParticles();
        animateParticles();
        
        // Инициализируем аудио
        const audioInitialized = await initAudio();
        
        if (audioInitialized) {
          log("Аудио инициализировано успешно", "info");
          
          // Подключаемся к WebSocket серверу
          const connected = await connectWebSocket();
          
          if (connected) {
            log("Подключение к WebSocket установлено", "info");
            
            // Настраиваем обработчики событий UI
            setupEventListeners();
            
            // Синхронизируем селектор голоса
            elements.voiceSelector.value = config.voice;
            
            // Устанавливаем режим прослушивания
            elements.listeningMode.value = config.listeningMode;
            
            log("Обработчики событий установлены", "info");
          } else {
            log("Не удалось установить подключение к WebSocket", "error");
            elements.loadingModal.style.display = 'none';
            showMessage("Не удалось подключиться к серверу. Проверьте соединение и обновите страницу.", 0);
          }
        } else {
          log("Не удалось инициализировать аудио", "error");
          elements.loadingModal.style.display = 'none';
          showMessage("Не удалось получить доступ к микрофону. Пожалуйста, разрешите доступ к микрофону и обновите страницу.", 0);
        }
      } catch (error) {
        log(`Ошибка инициализации: ${error.message}`, "error");
        elements.loadingModal.style.display = 'none';
        showMessage(`Произошла ошибка при инициализации: ${error.message}. Пожалуйста, обновите страницу.`, 0);
      }
    }
    
    // Настройка обработчиков событий
    function setupEventListeners() {
      // Обработка клика по сфере
      elements.sphere.addEventListener('click', toggleListening);
      
      // Настройки
      elements.settingsToggle.addEventListener('click', () => {
        elements.settingsPanel.classList.toggle('visible');
      });
      
      // Закрытие панели настроек при клике вне неё
      document.addEventListener('click', (e) => {
        if (elements.settingsPanel.classList.contains('visible') && 
            !elements.settingsPanel.contains(e.target) && 
            e.target !== elements.settingsToggle) {
          elements.settingsPanel.classList.remove('visible');
        }
      });
      
      // Изменение голоса
      elements.voiceSelector.addEventListener('change', (e) => {
        updateVoice(e.target.value);
      });
      
      // Изменение режима прослушивания
      elements.listeningMode.addEventListener('change', (e) => {
        setListeningMode(e.target.value);
      });
      
      // Отладочная панель
      document.addEventListener('keydown', (e) => {
        // Alt+D для отображения/скрытия отладочной панели
        if (e.altKey && e.key === 'd') {
          elements.debugPanel.classList.toggle('open');
        }
      });
      
      elements.debugClose.addEventListener('click', () => {
        elements.debugPanel.classList.remove('open');
      });
      
      // Обработка перед закрытием страницы
      window.addEventListener('beforeunload', () => {
        // Останавливаем переподключение при закрытии страницы
        state.shouldReconnect = false;
        
        // Закрываем соединение
        if (state.websocket && state.websocket.readyState === WebSocket.OPEN) {
          state.websocket.close();
        }
        
        // Останавливаем аудио
        if (state.mediaStream) {
          state.mediaStream.getTracks().forEach(track => track.stop());
        }
      });
    }
    
    // Запускаем инициализацию после загрузки страницы
    window.addEventListener('load', init);
  </script>
</body>
</html>
