<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>WellcomeAI</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <style>
    /* Reset и базовые стили */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      font-family: 'Segoe UI', 'Roboto', sans-serif;
    }
    
    body {
      background-color: #ffffff;
      color: #333;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      overflow: hidden;
    }
    
    /* Общие улучшения для мобильных */
    .mobile-device {
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
    }
    
    /* Специальные стили для iOS устройств */
    .ios-device {
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      -webkit-tap-highlight-color: rgba(0,0,0,0);
      -webkit-appearance: none;
      touch-action: manipulation;
    }
    
    /* Главный контейнер */
    .container {
      width: 100%;
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      position: relative;
    }
    
    /* Настройки */
    .settings-button {
      position: absolute;
      right: 20px;
      top: 20px;
      background: none;
      border: none;
      color: #777;
      font-size: 20px;
      cursor: pointer;
      opacity: 0.7;
      transition: opacity 0.3s, transform 0.3s;
      z-index: 10;
    }
    
    .settings-button:hover {
      opacity: 1;
      transform: rotate(30deg);
    }
    
    /* Telegram кнопка */
    .telegram-button {
      position: absolute;
      left: 20px;
      top: 20px;
      background: none;
      border: none;
      color: #0088cc;
      font-size: 24px;
      cursor: pointer;
      opacity: 0.8;
      transition: opacity 0.3s, transform 0.3s;
      z-index: 10;
      text-decoration: none;
      display: flex;
      align-items: center;
      gap: 5px;
    }
    
    .telegram-button:hover {
      opacity: 1;
      transform: scale(1.05);
    }
    
    .telegram-button span {
      font-size: 14px;
      font-weight: 500;
    }
    
    /* Основной элемент - круг */
    .main-circle {
      width: 280px;
      height: 280px;
      border-radius: 50%;
      background: linear-gradient(135deg, #ffffff, #e1f5fe, #4a86e8);
      box-shadow: 0 10px 20px rgba(0, 0, 0, 0.1);
      position: relative;
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s ease;
      z-index: 5;
      cursor: pointer;
    }
    
    .main-circle::before {
      content: '';
      position: absolute;
      width: 140%;
      height: 140%;
      background: linear-gradient(45deg, rgba(255, 255, 255, 0.3), rgba(74, 134, 232, 0.2));
      animation: wave 8s linear infinite;
      border-radius: 40%;
    }
    
    /* Анимация основной волны */
    @keyframes wave {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    /* Состояние прослушивания */
    .main-circle.listening {
      background: linear-gradient(135deg, #ffffff, #e3f2fd, #2196f3);
      box-shadow: 0 0 30px rgba(33, 150, 243, 0.6);
    }
    
    .main-circle.listening::before {
      animation: wave 4s linear infinite;
      background: linear-gradient(45deg, rgba(255, 255, 255, 0.5), rgba(33, 150, 243, 0.3));
    }
    
    /* Дополнительный эффект пульсации для прослушивания */
    .main-circle.listening::after {
      content: '';
      position: absolute;
      width: 100%;
      height: 100%;
      border-radius: 50%;
      border: 3px solid rgba(33, 150, 243, 0.5);
      animation: pulse 1.5s ease-out infinite;
    }
    
    @keyframes pulse {
      0% { 
        transform: scale(0.95);
        opacity: 0.7;
      }
      50% { 
        transform: scale(1.05);
        opacity: 0.3;
      }
      100% { 
        transform: scale(0.95);
        opacity: 0.7;
      }
    }
    
    /* Состояние говорения */
    .main-circle.speaking {
      background: linear-gradient(135deg, #ffffff, #e8f5e9, #4caf50);
      box-shadow: 0 0 30px rgba(76, 175, 80, 0.6);
    }
    
    .main-circle.speaking::before {
      animation: wave 3s linear infinite;
      background: linear-gradient(45deg, rgba(255, 255, 255, 0.5), rgba(76, 175, 80, 0.3));
    }
    
    /* Волновой эффект для говорения */
    .main-circle.speaking::after {
      content: '';
      position: absolute;
      width: 100%;
      height: 100%;
      background: radial-gradient(circle, transparent 50%, rgba(76, 175, 80, 0.1) 100%);
      border-radius: 50%;
      animation: ripple 2s ease-out infinite;
    }
    
    @keyframes ripple {
      0% { 
        transform: scale(0.8);
        opacity: 0;
      }
      50% { 
        opacity: 0.5;
      }
      100% { 
        transform: scale(1.2);
        opacity: 0;
      }
    }
    
    /* Состояние переключения голоса */
    .main-circle.voice-switching {
      background: linear-gradient(135deg, #ffffff, #fff8e1, #ffc107);
      box-shadow: 0 0 30px rgba(255, 193, 7, 0.6);
    }
    
    .main-circle.voice-switching::before {
      animation: wave 2s linear infinite;
      background: linear-gradient(45deg, rgba(255, 255, 255, 0.5), rgba(255, 193, 7, 0.3));
    }
    
    /* Эффект вращения для переключения голоса */
    .main-circle.voice-switching::after {
      content: '';
      position: absolute;
      width: 80%;
      height: 80%;
      border: 5px dashed rgba(255, 193, 7, 0.4);
      border-radius: 50%;
      animation: rotate 2s linear infinite;
    }
    
    @keyframes rotate {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    /* Аудио визуализация (скрытая) */
    .audio-visualization {
      position: absolute;
      width: 100%;
      max-width: 400px;
      height: 60px;
      opacity: 0;
      pointer-events: none;
    }
    
    .audio-bars {
      display: flex;
      align-items: flex-end;
      height: 40px;
      gap: 3px;
      width: 100%;
      justify-content: center;
    }
    
    .audio-bar {
      width: 4px;
      height: 2px;
      background-color: #4a86e8;
      border-radius: 2px;
      transition: height 0.1s ease;
    }
    
    /* Чат-контейнер (скрытый, но функциональный) */
    .chat-container {
      position: fixed;
      width: 100%;
      height: 100%;
      left: 0;
      top: 0;
      opacity: 0;
      pointer-events: none;
    }
    
    .messages {
      position: absolute;
      width: 1px;
      height: 1px;
      overflow: hidden;
    }
    
    /* Статус загрузки (скрытый) */
    .status {
      position: absolute;
      width: 1px;
      height: 1px;
      overflow: hidden;
      opacity: 0;
    }
    
    /* Транскрипция (скрытая) */
    .transcript {
      position: absolute;
      width: 1px;
      height: 1px;
      overflow: hidden;
      opacity: 0;
    }
    
    /* Модальное окно */
    .modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      opacity: 0;
      visibility: hidden;
      transition: all 0.3s;
    }
    
    .modal.active {
      opacity: 1;
      visibility: visible;
    }
    
    .modal-content {
      background-color: white;
      padding: 30px;
      border-radius: 16px;
      max-width: 500px;
      width: 100%;
      text-align: center;
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
      transform: scale(0.9);
      transition: transform 0.3s;
    }
    
    .modal.active .modal-content {
      transform: scale(1);
    }
    
    .modal h2 {
      color: #4a86e8;
      margin-top: 0;
      margin-bottom: 20px;
    }
    
    .modal p {
      margin-bottom: 20px;
      color: #555;
    }
    
    /* Модальное окно загрузки */
    .spinner {
      display: inline-block;
      width: 50px;
      height: 50px;
      border: 3px solid rgba(74, 134, 232, 0.3);
      border-radius: 50%;
      border-top-color: #4a86e8;
      animation: spin 1s linear infinite;
      margin-bottom: 20px;
    }
    
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    
    /* Модальное окно настроек */
    .settings-modal .modal-content {
      text-align: left;
    }
    
    .settings-group {
      margin-bottom: 20px;
    }
    
    .settings-group h3 {
      margin-bottom: 10px;
      font-size: 18px;
      color: #333;
    }
    
    .settings-option {
      margin-bottom: 15px;
    }
    
    .settings-option label {
      display: block;
      margin-bottom: 5px;
      color: #555;
    }
    
    .settings-voice-selector {
      width: 100%;
      padding: 10px;
      border-radius: 8px;
      border: 1px solid #ddd;
      font-size: 16px;
    }
    
    .setting-buttons {
      display: flex;
      justify-content: flex-end;
      margin-top: 20px;
    }
    
    .setting-button {
      padding: 10px 20px;
      border: none;
      border-radius: 8px;
      font-size: 16px;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .setting-button.cancel {
      background-color: #f5f5f5;
      color: #333;
      margin-right: 10px;
    }
    
    .setting-button.save {
      background-color: #4a86e8;
      color: white;
    }
    
    .setting-button:hover {
      opacity: 0.9;
    }
    
    /* Уведомление */
    .notification {
      position: fixed;
      bottom: 20px;
      right: 20px;
      padding: 15px 20px;
      background-color: rgba(76, 175, 80, 0.9);
      color: white;
      border-radius: 8px;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
      z-index: 1000;
      transform: translateY(100px);
      opacity: 0;
      transition: all 0.3s ease;
    }
    
    .notification.show {
      transform: translateY(0);
      opacity: 1;
    }
    
    .notification.error {
      background-color: rgba(244, 67, 54, 0.9);
    }
    
    /* Улучшения для мобильных устройств */
    @media (max-width: 768px) {
      body {
        position: fixed;
        width: 100%;
        height: 100%;
        overflow: hidden;
      }
      
      .container {
        padding: 10px;
        height: 100vh;
        justify-content: center;
      }
      
      /* Увеличиваем размер главного круга для удобства на мобильных */
      .main-circle {
        width: 250px !important;
        height: 250px !important;
        touch-action: manipulation;
        cursor: pointer;
      }
      
      /* Улучшенное позиционирование кнопок на мобильных */
      .settings-button {
        right: 15px;
        top: 15px;
        font-size: 24px;
        padding: 10px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 50%;
        width: 45px;
        height: 45px;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      
      .telegram-button {
        left: 15px;
        bottom: 15px;
        font-size: 20px;
        padding: 8px 12px;
        background: rgba(0, 136, 204, 0.1);
        border-radius: 25px;
        backdrop-filter: blur(10px);
      }
      
      /* Модальные окна на мобильных */
      .modal-content {
        margin: 20px;
        max-width: calc(100vw - 40px);
        max-height: calc(100vh - 40px);
        overflow-y: auto;
      }
      
      /* Настройки голоса для мобильных */
      .settings-voice-selector {
        font-size: 16px;
        padding: 12px;
        border-radius: 12px;
      }
      
      .setting-button {
        padding: 12px 24px;
        font-size: 16px;
        border-radius: 12px;
        min-height: 44px; /* Минимальный размер для удобного нажатия */
      }
      
      /* Уведомления для мобильных */
      .notification {
        bottom: 80px; /* Поднимаем выше для видимости */
        right: 15px;
        left: 15px;
        text-align: center;
        font-size: 16px;
        padding: 16px 20px;
        border-radius: 12px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        backdrop-filter: blur(10px);
      }
    }
    
    /* Дополнительные стили для очень маленьких экранов */
    @media (max-width: 480px) {
      .main-circle {
        width: 200px !important;
        height: 200px !important;
      }
      
      .settings-button {
        right: 10px;
        top: 10px;
        font-size: 20px;
        width: 40px;
        height: 40px;
      }
      
      .telegram-button {
        left: 10px;
        bottom: 10px;
        font-size: 18px;
        padding: 6px 10px;
      }
      
      /* Уменьшаем количество аудио-баров для экономии места */
      .audio-bar:nth-child(n+21) {
        display: none;
      }
      
      .audio-visualization {
        opacity: 0.6;
      }
    }
    
    /* Ландшафтная ориентация на мобильных */
    @media (max-width: 768px) and (orientation: landscape) {
      .main-circle {
        width: 180px !important;
        height: 180px !important;
      }
      
      .container {
        padding: 5px;
      }
    }
    
    /* Состояния для лучшей обратной связи на мобильных */
    .mobile-device .main-circle:active {
      transform: scale(0.95);
      transition: transform 0.1s ease;
    }
    
    .mobile-device .main-circle.listening {
      animation: mobile-listening-pulse 2s ease-in-out infinite;
    }
    
    @keyframes mobile-listening-pulse {
      0%, 100% {
        transform: scale(1);
        opacity: 1;
      }
      50% {
        transform: scale(1.02);
        opacity: 0.9;
      }
    }
    
    .mobile-device .main-circle.speaking {
      animation: mobile-speaking-bounce 1s ease-in-out infinite;
    }
    
    @keyframes mobile-speaking-bounce {
      0%, 100% {
        transform: scale(1);
      }
      50% {
        transform: scale(1.05);
      }
    }
    
    /* Улучшения для iOS Safari и других браузеров */
    .ios-device .main-circle {
      -webkit-touch-callout: none;
      -webkit-tap-highlight-color: transparent;
      -webkit-user-select: none;
      touch-action: manipulation;
      cursor: pointer;
      transform: translateZ(0); /* Активируем аппаратное ускорение */
      will-change: transform; /* Оптимизируем для анимаций */
    }
    
    /* Дополнительные визуальные эффекты для iOS */
    .ios-device .main-circle:active {
      transform: scale(0.98) translateZ(0);
      transition: transform 0.1s ease-out;
    }
    
    /* Фикс для iOS viewport */
    .ios-device body {
      position: fixed;
      width: 100%;
      height: 100vh;
      height: -webkit-fill-available; /* iOS Safari fix */
      overflow: hidden;
    }
    
    .ios-device .container {
      height: 100vh;
      height: -webkit-fill-available; /* iOS Safari fix */
      min-height: 100vh;
      min-height: -webkit-fill-available;
    }
    
    /* Улучшения для состояний на iOS */
    .ios-device .main-circle.listening {
      animation: ios-listening-pulse 2s ease-in-out infinite;
      transform: translateZ(0);
    }
    
    @keyframes ios-listening-pulse {
      0%, 100% {
        transform: scale(1) translateZ(0);
        opacity: 1;
      }
      50% {
        transform: scale(1.03) translateZ(0);
        opacity: 0.95;
      }
    }
    
    .ios-device .main-circle.speaking {
      animation: ios-speaking-bounce 1.2s ease-in-out infinite;
      transform: translateZ(0);
    }
    
    @keyframes ios-speaking-bounce {
      0%, 100% {
        transform: scale(1) translateZ(0);
      }
      25% {
        transform: scale(1.02) translateZ(0);
      }
      50% {
        transform: scale(1.05) translateZ(0);
      }
      75% {
        transform: scale(1.02) translateZ(0);
      }
    }
    
    /* Оптимизации для iOS Safari */
    .ios-device * {
      -webkit-overflow-scrolling: touch;
      -webkit-transform: translateZ(0);
    }
    
    /* Скрытие адресной строки в iOS Safari */
    @media screen and (max-width: 768px) {
      .ios-device {
        height: 100vh;
        height: -webkit-fill-available;
      }
      
      .ios-device .container {
        min-height: 100vh;
        min-height: -webkit-fill-available;
      }
    }
    
    /* Улучшения для уведомлений на iOS */
    .ios-device .notification {
      -webkit-backdrop-filter: blur(20px);
      backdrop-filter: blur(20px);
      border: 1px solid rgba(255, 255, 255, 0.2);
    }
    
    /* Дополнительные улучшения для сенсорных устройств */
    .mobile-device * {
      -webkit-overflow-scrolling: touch;
    }
    
    /* Предотвращаем zoom при double-tap */
    .mobile-device .main-circle {
      touch-action: manipulation;
    }
    
    /* iOS Safari специфичные улучшения */
    @supports (-webkit-touch-callout: none) {
      .mobile-device {
        -webkit-appearance: none;
      }
      
      .main-circle {
        -webkit-tap-highlight-color: transparent;
      }
      
      /* Исправляем проблемы с viewport в iOS */
      .container {
        height: -webkit-fill-available;
        min-height: 100vh;
      }
    }
    
    /* Темная тема для мобильных (если системная тема темная) */
    @media (prefers-color-scheme: dark) and (max-width: 768px) {
      body {
        background-color: #1a1a1a;
        color: #ffffff;
      }
      
      .main-circle {
        background: linear-gradient(135deg, #2a2a2a, #1e3a5f, #4a86e8) !important;
      }
      
      .settings-button {
        background: rgba(255, 255, 255, 0.1);
        color: #ffffff;
      }
      
      .telegram-button {
        background: rgba(0, 136, 204, 0.2);
        color: #0088cc;
      }
    }
    
    /* Стили для темной темы на iOS */
    @media (prefers-color-scheme: dark) {
      .ios-device body {
        background-color: #000000;
        color: #ffffff;
      }
      
      .ios-device .main-circle {
        background: linear-gradient(135deg, #1c1c1e, #2c2c2e, #4a86e8) !important;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5) !important;
      }
      
      .ios-device .settings-button {
        background: rgba(255, 255, 255, 0.1);
        color: #ffffff;
        backdrop-filter: blur(20px);
      }
      
      .ios-device .telegram-button {
        background: rgba(0, 136, 204, 0.2);
        color: #0a84ff;
        backdrop-filter: blur(20px);
      }
    }
    
    /* Индикатор активности микрофона для мобильных */
    .mobile-device .main-circle.listening::before {
      animation: wave 3s linear infinite !important;
    }
    
    .mobile-device .main-circle.speaking::before {
      animation: wave 2s linear infinite !important;
    }
    
    .ios-device .main-circle.listening::before {
      animation: wave 3s linear infinite !important;
    }
    
    .ios-device .main-circle.speaking::before {
      animation: wave 2s linear infinite !important;
    }
  </style>
</head>
<body>
  <!-- Модальное окно загрузки -->
  <div id="loading-modal" class="modal active">
    <div class="modal-content">
      <div class="spinner"></div>
      <h2>WellcomeAI</h2>
      <p>Подключение...</p>
      <div id="loading-status">Инициализация...</div>
    </div>
  </div>
  
  <!-- Модальное окно настроек -->
  <div id="settings-modal" class="modal settings-modal">
    <div class="modal-content">
      <h2>Настройки</h2>
      
      <div class="settings-group">
        <h3>Голос ассистента</h3>
        <div class="settings-option">
          <label for="voice-selector">Выберите голос:</label>
          <select id="voice-selector" class="settings-voice-selector">
            <option value="alloy">Alloy</option>
            <option value="ash">Ash</option>
            <option value="ballad">Ballad</option>
            <option value="coral">Coral</option>
            <option value="echo">Echo</option>
            <option value="sage">Sage</option>
            <option value="shimmer">Shimmer</option>
            <option value="verse">Verse</option>
          </select>
        </div>
      </div>
      
      <div class="setting-buttons">
        <button class="setting-button cancel" id="settings-cancel">Отмена</button>
        <button class="setting-button save" id="settings-save">Сохранить</button>
      </div>
    </div>
  </div>

  <!-- Уведомление -->
  <div id="notification" class="notification">
    Сообщение уведомления
  </div>

  <div class="container">
    <!-- Ссылка на Telegram канал -->
    <a href="https://t.me/wellcome_AI" target="_blank" class="telegram-button">
      <i class="fab fa-telegram"></i>
      <span>Подписаться</span>
    </a>
    
    <button class="settings-button" id="settings-button">
      <i class="fas fa-cog"></i>
    </button>
    
    <div class="main-circle" id="main-circle"></div>
    
    <div class="audio-visualization" id="audio-visualization">
      <div class="audio-bars" id="audio-bars"></div>
    </div>
    
    <div class="transcript" id="transcript"></div>
    
    <div class="chat-container">
      <div class="messages" id="messages"></div>
    </div>
    
    <div class="status" id="status"></div>
  </div>

  <script>
    // НАСТРОЙКИ И ОПРЕДЕЛЕНИЕ УСТРОЙСТВА
    
    // Определение мобильного устройства
    function isMobileDevice() {
      return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
             ('ontouchstart' in window) ||
             (navigator.maxTouchPoints > 0);
    }
    
    // Определение iOS устройства (все браузеры)
    function isIOS() {
      return /iPad|iPhone|iPod/.test(navigator.userAgent) || 
             (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
    }
    
    // Элементы UI
    const mainCircle = document.getElementById('main-circle');
    const messagesContainer = document.getElementById('messages');
    const statusElement = document.getElementById('status');
    const transcriptElement = document.getElementById('transcript');
    const loadingModal = document.getElementById('loading-modal');
    const loadingStatus = document.getElementById('loading-status');
    const audioBars = document.getElementById('audio-bars');
    const notification = document.getElementById('notification');
    
    // Элементы настроек
    const settingsButton = document.getElementById('settings-button');
    const settingsModal = document.getElementById('settings-modal');
    const settingsSave = document.getElementById('settings-save');
    const settingsCancel = document.getElementById('settings-cancel');
    const voiceSelector = document.getElementById('voice-selector');
    
    // Настройки пользователя
    let userSettings = {
      voice: "alloy"
    };
    
    // Переменные для обработки аудио
    let audioChunksBuffer = []; // Буфер для хранения аудио чанков
    let audioPlaybackQueue = []; // Очередь для полного воспроизведения аудио
    let isPlayingAudio = false; // Флаг воспроизведения аудио
    let hasAudioData = false;   // Флаг наличия аудиоданных в буфере
    let audioDataStartTime = 0; // Время начала записи аудио
    let minimumAudioLength = 300; // Минимальная длительность аудио (мс)
    let reconnecting = false;   // Флаг переподключения/смены голоса
    
    // Переменные для мобильной поддержки
    let audioContextUnlocked = false;
    let userInteractionOccurred = false;
    let audioElements = []; // Массив для хранения Audio элементов
    let mobileAudioEnabled = false;
    
    // Переменные для универсальной iOS поддержки
    let iosAudioFullyUnlocked = false;
    let iosPrewarmedAudio = [];
    let iosAudioPool = [];
    let iosUserInteractionCompleted = false;
    let iosAudioWarmupTimeout = null;
    
    // НОВЫЕ ПЕРЕМЕННЫЕ ДЛЯ ИСПРАВЛЕНИЯ АУДИОБУФЕРА
    let audioDataAccumulated = 0; // Счетчик накопленных аудио данных
    let lastAudioReceiveTime = 0; // Время последнего получения аудио
    let audioCommitInProgress = false; // Флаг процесса коммита
    let silenceDetectionActive = true; // Флаг активности детекции тишины
    
    // Функция логирования
    function log(message, level = 'info') {
      const timestamp = new Date().toLocaleTimeString();
      // Отфильтровываем сообщения о WebSocket URL
      if (message && message.includes("WebSocket URL:")) {
        return;
      }
      console.log(`[${level.toUpperCase()}] ${message}`);
      
      // Обновляем статус загрузки, если это информационное сообщение
      if (level === 'info' && loadingModal.classList.contains('active')) {
        loadingStatus.textContent = message;
      }
    }
    
    // Показать уведомление
    function showNotification(message, isError = false) {
      // Пропускаем сообщения об ошибках с пустым буфером
      if (message && (message.includes("Недостаточно аудио") || message.includes("буфер"))) {
        return;
      }
      
      // Очищаем предыдущие таймауты
      if (notification.timeout) {
        clearTimeout(notification.timeout);
      }
      
      // Устанавливаем сообщение и стиль
      notification.textContent = message;
      notification.classList.remove('show', 'error');
      
      if (isError) {
        notification.classList.add('error');
      }
      
      // Показываем уведомление с небольшой задержкой
      setTimeout(() => {
        notification.classList.add('show');
      }, 10);
      
      // Скрываем уведомление через 3 секунды
      notification.timeout = setTimeout(() => {
        notification.classList.remove('show');
      }, 3000);
    }
    
    // Создаем аудио-бары для визуализации
    function createAudioBars(count = 30) {
      audioBars.innerHTML = '';
      for (let i = 0; i < count; i++) {
        const bar = document.createElement('div');
        bar.className = 'audio-bar';
        audioBars.appendChild(bar);
      }
    }
    createAudioBars();
    
    // Состояние
    let isConnected = false;
    let isListening = false;
    let isProcessing = false;
    let websocket = null;
    let audioContext = null;
    let mediaStream = null;
    let audioProcessor = null;
    let lastSilenceTime = 0;
    let audioBufferTimeoutId = null;
    
    // Конфигурация для оптимизации потока аудио
    const AUDIO_CONFIG = {
      silenceThreshold: 0.01,      // Порог для определения тишины
      silenceDuration: 300,        // Длительность тишины для отправки (мс)
      bufferCheckInterval: 50,     // Частота проверки буфера (мс)
      soundDetectionThreshold: 0.02 // Чувствительность к звуку
    };
    
    // ФУНКЦИИ ДЛЯ УНИВЕРСАЛЬНОЙ iOS ПОДДЕРЖКИ
    
    // Универсальная агрессивная активация аудио для iOS
    async function universalIOSAudioUnlock() {
      if (!isIOS() || iosAudioFullyUnlocked) return true;
      
      try {
        log("Универсальная активация аудио для iOS (все браузеры)...");
        
        // 1. Активируем AudioContext максимально агрессивно
        if (audioContext) {
          if (audioContext.state === 'suspended') {
            await audioContext.resume();
          }
          
          // Создаем и воспроизводим беззвучный звук для активации
          const oscillator = audioContext.createOscillator();
          const gainNode = audioContext.createGain();
          oscillator.connect(gainNode);
          gainNode.connect(audioContext.destination);
          gainNode.gain.setValueAtTime(0, audioContext.currentTime);
          oscillator.frequency.setValueAtTime(220, audioContext.currentTime);
          oscillator.start(audioContext.currentTime);
          oscillator.stop(audioContext.currentTime + 0.01);
        }
        
        // 2. Создаем пул предактивированных Audio элементов
        await createIOSAudioPool();
        
        // 3. Прогреваем аудио систему
        await warmupIOSAudio();
        
        iosAudioFullyUnlocked = true;
        iosUserInteractionCompleted = true;
        
        log("iOS аудио полностью активировано!");
        return true;
        
      } catch (error) {
        log(`Ошибка активации iOS аудио: ${error.message}`, "error");
        return false;
      }
    }
    
    // Создание пула Audio элементов для iOS
    async function createIOSAudioPool() {
      if (!isIOS()) return;
      
      try {
        // Создаем несколько Audio элементов заранее
        for (let i = 0; i < 5; i++) {
          const audio = new Audio();
          
          // Устанавливаем data URL с минимальным WAV файлом
          audio.src = "data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUYrTp66hVFApGn+DyvmwhBLqUm";
          
          // Важные настройки для iOS
          audio.preload = 'auto';
          audio.loop = false;
          audio.muted = true; // Начинаем с muted, потом включим
          audio.autoplay = false;
          audio.controls = false;
          
          // Добавляем в пул
          iosAudioPool.push(audio);
          
          // Пытаемся загрузить и активировать
          try {
            audio.load();
            // Воспроизводим беззвучно для активации
            const playPromise = audio.play();
            if (playPromise) {
              await playPromise;
              audio.pause();
              audio.currentTime = 0;
              audio.muted = false; // Включаем звук после активации
            }
          } catch (e) {
            // Игнорируем ошибки при предварительной активации
          }
        }
        
        log(`iOS аудио пул создан: ${iosAudioPool.length} элементов`);
        
      } catch (error) {
        log(`Ошибка создания iOS аудио пула: ${error.message}`, "error");
      }
    }
    
    // Прогрев аудио системы iOS
    async function warmupIOSAudio() {
      if (!isIOS()) return;
      
      try {
        // Создаем несколько коротких аудио файлов разной частоты
        const frequencies = [220, 440, 880];
        
        for (const freq of frequencies) {
          const audio = new Audio();
          
          // Генерируем короткий тон
          const duration = 0.1; // 100ms
          const sampleRate = 24000;
          const samples = Math.floor(sampleRate * duration);
          
          // Создаем WAV с тоном
          const wavBuffer = generateToneWAV(freq, duration, sampleRate);
          const blob = new Blob([wavBuffer], { type: 'audio/wav' });
          const audioUrl = URL.createObjectURL(blob);
          
          audio.src = audioUrl;
          audio.volume = 0.01; // Очень тихо
          audio.preload = 'auto';
          
          try {
            audio.load();
            const playPromise = audio.play();
            if (playPromise) {
              await playPromise;
              audio.pause();
            }
            URL.revokeObjectURL(audioUrl);
          } catch (e) {
            // Игнорируем ошибки прогрева
          }
        }
        
        log("iOS аудио прогрев завершен");
        
      } catch (error) {
        log(`Ошибка прогрева iOS аудио: ${error.message}`, "error");
      }
    }
    
    // Генерация WAV файла с тоном для прогрева
    function generateToneWAV(frequency, duration, sampleRate) {
      const samples = Math.floor(sampleRate * duration);
      const buffer = new ArrayBuffer(44 + samples * 2);
      const view = new DataView(buffer);
      
      // WAV заголовок
      const writeString = (offset, string) => {
        for (let i = 0; i < string.length; i++) {
          view.setUint8(offset + i, string.charCodeAt(i));
        }
      };
      
      writeString(0, 'RIFF');
      view.setUint32(4, 36 + samples * 2, true);
      writeString(8, 'WAVE');
      writeString(12, 'fmt ');
      view.setUint32(16, 16, true);
      view.setUint16(20, 1, true);
      view.setUint16(22, 1, true);
      view.setUint32(24, sampleRate, true);
      view.setUint32(28, sampleRate * 2, true);
      view.setUint16(32, 2, true);
      view.setUint16(34, 16, true);
      writeString(36, 'data');
      view.setUint32(40, samples * 2, true);
      
      // Генерируем синусоидальный тон
      let offset = 44;
      for (let i = 0; i < samples; i++) {
        const sample = Math.sin(2 * Math.PI * frequency * i / sampleRate);
        view.setInt16(offset, sample * 32767 * 0.1, true); // Тихий звук
        offset += 2;
      }
      
      return buffer;
    }
    
    // Получение предактивированного Audio элемента для iOS
    function getIOSAudioElement() {
      if (!isIOS() || iosAudioPool.length === 0) {
        return new Audio();
      }
      
      // Берем элемент из пула или создаем новый
      let audio = iosAudioPool.shift();
      
      if (!audio) {
        audio = new Audio();
        audio.preload = 'auto';
      }
      
      // Если пул опустел, пополняем его асинхронно
      if (iosAudioPool.length < 2) {
        setTimeout(createIOSAudioPool, 100);
      }
      
      return audio;
    }
    
    // ФУНКЦИИ ДЛЯ МОБИЛЬНОЙ ПОДДЕРЖКИ
    
    // Функция для активации аудио на мобильных устройствах
    async function unlockAudioContext() {
      if (audioContextUnlocked || !audioContext) return true;
      
      try {
        // Создаем короткий звук для разблокировки
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);
        
        gainNode.gain.setValueAtTime(0, audioContext.currentTime);
        oscillator.frequency.setValueAtTime(440, audioContext.currentTime);
        
        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + 0.01);
        
        // Возобновляем контекст
        if (audioContext.state === 'suspended') {
          await audioContext.resume();
        }
        
        audioContextUnlocked = true;
        mobileAudioEnabled = true;
        log("AudioContext разблокирован для мобильного устройства");
        
        return true;
      } catch (error) {
        log(`Ошибка разблокировки AudioContext: ${error.message}`, "error");
        return false;
      }
    }
    
    // Улучшенная функция создания WAV для мобильных устройств
    function createWavFromPcmMobile(pcmBuffer, sampleRate = 24000) {
      try {
        // Проверяем входные данные
        if (!pcmBuffer || pcmBuffer.byteLength === 0) {
          log("Пустые PCM данные", "warn");
          return null;
        }
        
        // Создаём заголовок WAV с корректными параметрами для мобильных
        const wavHeader = new ArrayBuffer(44);
        const view = new DataView(wavHeader);
        
        // RIFF header
        view.setUint8(0, 'R'.charCodeAt(0));
        view.setUint8(1, 'I'.charCodeAt(0));
        view.setUint8(2, 'F'.charCodeAt(0));
        view.setUint8(3, 'F'.charCodeAt(0));
        view.setUint32(4, 36 + pcmBuffer.byteLength, true);
        
        // WAVE header
        view.setUint8(8, 'W'.charCodeAt(0));
        view.setUint8(9, 'A'.charCodeAt(0));
        view.setUint8(10, 'V'.charCodeAt(0));
        view.setUint8(11, 'E'.charCodeAt(0));
        
        // fmt chunk
        view.setUint8(12, 'f'.charCodeAt(0));
        view.setUint8(13, 'm'.charCodeAt(0));
        view.setUint8(14, 't'.charCodeAt(0));
        view.setUint8(15, ' '.charCodeAt(0));
        view.setUint32(16, 16, true);
        view.setUint16(20, 1, true);
        view.setUint16(22, 1, true);
        view.setUint32(24, sampleRate, true);
        view.setUint32(28, sampleRate * 2, true);
        view.setUint16(32, 2, true);
        view.setUint16(34, 16, true);
        
        // data chunk
        view.setUint8(36, 'd'.charCodeAt(0));
        view.setUint8(37, 'a'.charCodeAt(0));
        view.setUint8(38, 't'.charCodeAt(0));
        view.setUint8(39, 'a'.charCodeAt(0));
        view.setUint32(40, pcmBuffer.byteLength, true);
        
        // Объединяем заголовок и данные
        const wavBuffer = new ArrayBuffer(wavHeader.byteLength + pcmBuffer.byteLength);
        const wavBytes = new Uint8Array(wavBuffer);
        
        wavBytes.set(new Uint8Array(wavHeader), 0);
        wavBytes.set(new Uint8Array(pcmBuffer), wavHeader.byteLength);
        
        return wavBuffer;
      } catch (error) {
        log(`Ошибка создания WAV для мобильного: ${error.message}`, "error");
        return null;
      }
    }
    
    // Функция активации аудио по взаимодействию пользователя
    async function enableAudioOnUserInteraction() {
      if (userInteractionOccurred) return;
      
      userInteractionOccurred = true;
      
      if (isMobileDevice()) {
        await unlockAudioContext();
        
        // Показываем уведомление о готовности
        showNotification("Аудио активировано! Можете общаться с ассистентом.", false);
      }
    }
    
    // НОВЫЕ ФУНКЦИИ ДЛЯ ИСПРАВЛЕНИЯ АУДИОБУФЕРА
    
    // Обновленная функция обработки аудио для всех устройств
    function createUniversalAudioProcessor(audioProcessor, isIOSDevice = false) {
      // Переменные для отслеживания звука
      let isSilent = true;
      let silenceStartTime = Date.now();
      let lastCommitTime = 0;
      let hasSentAudioInCurrentSegment = false;
      let consecutiveSilentFrames = 0;
      let consecutiveSoundFrames = 0;
      
      audioProcessor.onaudioprocess = function(e) {
        if (!isListening || !websocket || websocket.readyState !== WebSocket.OPEN || reconnecting || audioCommitInProgress) {
          return;
        }
        
        const inputData = e.inputBuffer.getChannelData(0);
        
        // Вычисляем максимальную амплитуду и RMS
        let maxAmplitude = 0;
        let rmsAmplitude = 0;
        for (let i = 0; i < inputData.length; i++) {
          const absValue = Math.abs(inputData[i]);
          maxAmplitude = Math.max(maxAmplitude, absValue);
          rmsAmplitude += absValue * absValue;
        }
        rmsAmplitude = Math.sqrt(rmsAmplitude / inputData.length);
        
        // Используем RMS для более точного определения звука
        const hasSound = rmsAmplitude > AUDIO_CONFIG.soundDetectionThreshold;
        
        // Обновляем визуализацию
        updateAudioVisualization(inputData);
        
        // Сглаживание детекции звука
        if (hasSound) {
          consecutiveSoundFrames++;
          consecutiveSilentFrames = 0;
        } else {
          consecutiveSilentFrames++;
          consecutiveSoundFrames = 0;
        }
        
        // Требуем несколько кадров подряд для уверенности
        const soundConfirmed = consecutiveSoundFrames >= 2;
        const silenceConfirmed = consecutiveSilentFrames >= 3;
        
        // Отправляем аудио данные только если есть звук
        if (soundConfirmed || (!isSilent && !silenceConfirmed)) {
          // Преобразуем в PCM16
          const pcm16Data = new Int16Array(inputData.length);
          for (let i = 0; i < inputData.length; i++) {
            pcm16Data[i] = Math.max(-32768, Math.min(32767, Math.floor(inputData[i] * 32767)));
          }
          
          // Отправляем данные
          try {
            const message = JSON.stringify({
              type: "input_audio_buffer.append",
              event_id: `audio_${Date.now()}`,
              audio: arrayBufferToBase64(pcm16Data.buffer)
            });
            
            websocket.send(message);
            hasSentAudioInCurrentSegment = true;
            
            // Обновляем счетчики
            audioDataAccumulated += inputData.length;
            lastAudioReceiveTime = Date.now();
            
            if (!hasAudioData && soundConfirmed) {
              hasAudioData = true;
              audioDataStartTime = Date.now();
              log("Начало записи аудиоданных (улучшенная логика)");
            }
            
          } catch (error) {
            log(`Ошибка отправки аудио: ${error.message}`, "error");
          }
        }
        
        // Улучшенная логика определения тишины
        const now = Date.now();
        
        if (soundConfirmed) {
          // Подтвержденный звук
          isSilent = false;
          silenceStartTime = now;
          
          if (!mainCircle.classList.contains('listening') && 
              !mainCircle.classList.contains('speaking') && 
              !mainCircle.classList.contains('voice-switching')) {
            mainCircle.classList.add('listening');
          }
          
          // Очищаем предыдущий таймаут
          if (audioBufferTimeoutId) {
            clearTimeout(audioBufferTimeoutId);
            audioBufferTimeoutId = null;
          }
        } else if (!isSilent && silenceConfirmed) {
          // Подтвержденная тишина
          const silenceDuration = now - silenceStartTime;
          
          if (silenceDuration > AUDIO_CONFIG.silenceDuration && silenceDetectionActive) {
            isSilent = true;
            
            // Проверяем условия для коммита
            const hasEnoughAudio = audioDataAccumulated > 2400; // ~100ms при 24kHz
            const hasRecentAudio = (now - lastAudioReceiveTime) < 1000;
            const timeSinceLastCommit = now - lastCommitTime;
            
            if (hasEnoughAudio && hasRecentAudio && timeSinceLastCommit > 1000 && hasSentAudioInCurrentSegment) {
              // Отправляем буфер с задержкой для уверенности
              if (!audioBufferTimeoutId) {
                audioBufferTimeoutId = setTimeout(() => {
                  if (isSilent && isListening && !audioCommitInProgress && !reconnecting && hasAudioData) {
                    commitAudioBufferSafe();
                    lastCommitTime = Date.now();
                    hasSentAudioInCurrentSegment = false;
                  }
                  audioBufferTimeoutId = null;
                }, 150);
              }
            }
          }
        }
      };
    }
    
    // Безопасная функция коммита аудиобуфера
    function commitAudioBufferSafe() {
      if (!isListening || isProcessing || !websocket || websocket.readyState !== WebSocket.OPEN || reconnecting || audioCommitInProgress) {
        log("Коммит отменен: неподходящие условия", "warn");
        return;
      }
      
      // Дополнительные проверки
      if (!hasAudioData || audioDataAccumulated === 0) {
        log("Коммит отменен: нет аудиоданных", "warn");
        resetAudioState();
        return;
      }
      
      // Проверяем минимальную длительность
      const audioLength = Date.now() - audioDataStartTime;
      const estimatedDuration = (audioDataAccumulated / 24000) * 1000; // мс
      
      if (audioLength < minimumAudioLength || estimatedDuration < 100) {
        log(`Коммит отменен: слишком короткое аудио (${audioLength}мс, ${estimatedDuration.toFixed(1)}мс)`, "warn");
        
        // Ждем еще немного
        setTimeout(() => {
          if (isListening && hasAudioData && !audioCommitInProgress && !reconnecting) {
            const newLength = Date.now() - audioDataStartTime;
            if (newLength >= minimumAudioLength) {
              commitAudioBufferSafe();
            } else {
              log("Окончательный отказ от коммита - аудио слишком короткое");
              resetAudioState();
            }
          }
        }, minimumAudioLength - audioLength + 100);
        
        return;
      }
      
      // Если все проверки пройдены, отправляем буфер
      sendCommitBufferSafe();
    }
    
    // Безопасная отправка буфера
    function sendCommitBufferSafe() {
      if (audioCommitInProgress) {
        log("Коммит уже в процессе, пропускаем", "warn");
        return;
      }
      
      audioCommitInProgress = true;
      silenceDetectionActive = false; // Временно отключаем детекцию
      
      log(`Отправка аудиобуфера (накоплено: ${audioDataAccumulated} сэмплов, длительность: ${((audioDataAccumulated / 24000) * 1000).toFixed(1)}мс)`);
      
      // Сбрасываем визуальные эффекты
      mainCircle.classList.remove('listening');
      
      try {
        // Отправляем команду коммита
        websocket.send(JSON.stringify({
          type: "input_audio_buffer.commit",
          event_id: `commit_${Date.now()}`
        }));
        
        // Начинаем обработку
        isProcessing = true;
        
        // Сбрасываем состояние аудио
        resetAudioState();
        
        log("Аудиобуфер успешно отправлен");
        
      } catch (error) {
        log(`Ошибка отправки коммита: ${error.message}`, "error");
        audioCommitInProgress = false;
        silenceDetectionActive = true;
      }
    }
    
    // Сброс состояния аудио
    function resetAudioState() {
      hasAudioData = false;
      audioDataStartTime = 0;
      audioDataAccumulated = 0;
      lastAudioReceiveTime = 0;
    }
    
    // Обновленная функция обработки событий сервера
    function handleAudioCommitResponse(event) {
      if (event.type === "input_audio_buffer.committed") {
        log("Буфер подтвержден сервером");
        audioCommitInProgress = false;
      } else if (event.type === "response.done") {
        log("Ответ завершен, сбрасываем флаги");
        audioCommitInProgress = false;
        silenceDetectionActive = true;
        isProcessing = false;
        
        // Небольшая задержка перед повторным слушанием
        setTimeout(() => {
          if (!isPlayingAudio) {
            mainCircle.classList.remove('speaking');
          }
          
          if (!isListening && !reconnecting) {
            startListening();
          }
        }, isMobileDevice() ? 500 : 300);
      } else if (event.type === "error" && event.error && event.error.message.includes("buffer too small")) {
        log("Получена ошибка пустого буфера, сбрасываем состояние");
        audioCommitInProgress = false;
        silenceDetectionActive = true;
        resetAudioState();
        
        // Перезапускаем слушание
        setTimeout(() => {
          if (!isListening && !reconnecting) {
            startListening();
          }
        }, 500);
      }
    }
    
    // ОСНОВНЫЕ ФУНКЦИИ АУДИО (ИСПРАВЛЕННЫЕ)
    
    // Инициализация микрофона и AudioContext для мобильных устройств (исправленная версия)
    async function initAudioMobileFixed() {
      try {
        log("Инициализация аудио для мобильного устройства (исправленная версия)...");
        
        const constraints = {
          audio: {
            echoCancellation: true,
            noiseSuppression: true,
            autoGainControl: true,
            sampleRate: { ideal: 24000, min: 16000, max: 48000 },
            channelCount: { ideal: 1 }
          }
        };
        
        mediaStream = await navigator.mediaDevices.getUserMedia(constraints);
        log("Доступ к микрофону получен на мобильном устройстве");
        
        const AudioContextClass = window.AudioContext || window.webkitAudioContext;
        audioContext = new AudioContextClass({ 
          sampleRate: 24000,
          latencyHint: 'interactive'
        });
        
        log(`AudioContext создан с частотой ${audioContext.sampleRate} Гц`);
        
        const streamSource = audioContext.createMediaStreamSource(mediaStream);
        const bufferSize = 1024;
        audioProcessor = audioContext.createScriptProcessor(bufferSize, 1, 1);
        
        // Используем улучшенный обработчик
        createUniversalAudioProcessor(audioProcessor, isIOS());
        
        streamSource.connect(audioProcessor);
        audioProcessor.connect(audioContext.destination);
        
        log("Аудио инициализировано для мобильного устройства (исправленная версия)");
        return true;
        
      } catch (error) {
        log(`Ошибка инициализации аудио на мобильном: ${error.message}`, "error");
        showNotification("Ошибка доступа к микрофону. Проверьте настройки браузера.", true);
        return false;
      }
    }
    
    // Инициализация микрофона и AudioContext для десктопа (исправленная версия)
    async function initAudioFixed() {
      try {
        log("Запрос разрешения на доступ к микрофону (исправленная версия)...");
        
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
          throw new Error("Ваш браузер не поддерживает доступ к микрофону");
        }
        
        mediaStream = await navigator.mediaDevices.getUserMedia({ 
          audio: {
            echoCancellation: true,
            noiseSuppression: true,
            autoGainControl: true,
            sampleRate: 24000
          } 
        });
        
        log("Доступ к микрофону получен");
        
        audioContext = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 24000 });
        log(`AudioContext создан с частотой ${audioContext.sampleRate} Гц`);
        
        const streamSource = audioContext.createMediaStreamSource(mediaStream);
        const bufferSize = 2048;
        
        if (audioContext.createScriptProcessor) {
          audioProcessor = audioContext.createScriptProcessor(bufferSize, 1, 1);
          log("Создан ScriptProcessorNode для обработки аудио");
        } else {
          throw new Error("Ваш браузер не поддерживает ScriptProcessorNode");
        }
        
        // Используем улучшенный обработчик
        createUniversalAudioProcessor(audioProcessor, false);
        
        streamSource.connect(audioProcessor);
        audioProcessor.connect(audioContext.destination);
        
        log("Аудио инициализировано успешно (исправленная версия)");
        return true;
      } catch (error) {
        log(`Ошибка инициализации аудио: ${error.message}`, "error");
        showNotification("Ошибка доступа к микрофону. Проверьте настройки браузера.", true);
        return false;
      }
    }
    
    // Преобразование ArrayBuffer в Base64
    function arrayBufferToBase64(buffer) {
      const bytes = new Uint8Array(buffer);
      let binary = '';
      for (let i = 0; i < bytes.byteLength; i++) {
        binary += String.fromCharCode(bytes[i]);
      }
      return btoa(binary);
    }
    
    // Преобразование Base64 в ArrayBuffer
    function base64ToArrayBuffer(base64) {
      try {
        const binaryString = atob(base64);
        const bytes = new Uint8Array(binaryString.length);
        for (let i = 0; i < binaryString.length; i++) {
          bytes[i] = binaryString.charCodeAt(i);
        }
        return bytes.buffer;
      } catch (e) {
        log(`Ошибка при декодировании base64: ${e.message}`, "error");
        return new ArrayBuffer(0);
      }
    }
    
    // Обновление визуализации аудио
    function updateAudioVisualization(audioData) {
      const bars = audioBars.querySelectorAll('.audio-bar');
      const step = Math.floor(audioData.length / bars.length);
      
      for (let i = 0; i < bars.length; i++) {
        // Вычисляем среднее значение амплитуды для этого "отрезка" аудиоданных
        let sum = 0;
        for (let j = 0; j < step; j++) {
          const index = i * step + j;
          if (index < audioData.length) {
            sum += Math.abs(audioData[index]);
          }
        }
        const average = sum / step;
        
        // Нормализуем значение для высоты полосы (от 2px до 40px)
        const height = 2 + Math.min(38, Math.floor(average * 100));
        bars[i].style.height = `${height}px`;
      }
    }
    
    // Сброс визуализации аудио
    function resetAudioVisualization() {
      const bars = audioBars.querySelectorAll('.audio-bar');
      bars.forEach(bar => {
        bar.style.height = '2px';
      });
    }
    
    // Создаём простой WAV из PCM данных
    function createWavFromPcm(pcmBuffer, sampleRate = 24000) {
      // Создаём заголовок WAV
      const wavHeader = new ArrayBuffer(44);
      const view = new DataView(wavHeader);
      
      // "RIFF" chunk descriptor
      view.setUint8(0, 'R'.charCodeAt(0));
      view.setUint8(1, 'I'.charCodeAt(0));
      view.setUint8(2, 'F'.charCodeAt(0));
      view.setUint8(3, 'F'.charCodeAt(0));
      
      view.setUint32(4, 36 + pcmBuffer.byteLength, true); // Размер всего файла - 8
      
      // "WAVE" формат
      view.setUint8(8, 'W'.charCodeAt(0));
      view.setUint8(9, 'A'.charCodeAt(0));
      view.setUint8(10, 'V'.charCodeAt(0));
      view.setUint8(11, 'E'.charCodeAt(0));
      
      // "fmt " субчанк
      view.setUint8(12, 'f'.charCodeAt(0));
      view.setUint8(13, 'm'.charCodeAt(0));
      view.setUint8(14, 't'.charCodeAt(0));
      view.setUint8(15, ' '.charCodeAt(0));
      
      view.setUint32(16, 16, true); // Размер fmt субчанка
      view.setUint16(20, 1, true);  // Формат аудио (1 = PCM)
      view.setUint16(22, 1, true);  // Число каналов (1 = моно)
      view.setUint32(24, sampleRate, true); // Частота дискретизации
      view.setUint32(28, sampleRate * 2, true); // Байт в секунду (SampleRate * NumChannels * BitsPerSample/8)
      view.setUint16(32, 2, true);  // Байт на сэмпл (NumChannels * BitsPerSample/8)
      view.setUint16(34, 16, true); // Бит на сэмпл
      
      // "data" субчанк
      view.setUint8(36, 'd'.charCodeAt(0));
      view.setUint8(37, 'a'.charCodeAt(0));
      view.setUint8(38, 't'.charCodeAt(0));
      view.setUint8(39, 'a'.charCodeAt(0));
      
      view.setUint32(40, pcmBuffer.byteLength, true); // Размер данных
      
      // Объединяем заголовок и PCM данные
      const wavBuffer = new ArrayBuffer(wavHeader.byteLength + pcmBuffer.byteLength);
      const wavBytes = new Uint8Array(wavBuffer);
      
      wavBytes.set(new Uint8Array(wavHeader), 0);
      wavBytes.set(new Uint8Array(pcmBuffer), wavHeader.byteLength);
      
      return wavBuffer;
    }
    
    // Улучшенная функция воспроизведения для iOS
    function playNextAudioIOS() {
      if (audioPlaybackQueue.length === 0) {
        isPlayingAudio = false;
        mainCircle.classList.remove('speaking');
        
        // Начинаем слушать снова
        setTimeout(() => {
          if (!isListening && !reconnecting) {
            startListening();
          }
        }, 300);
        return;
      }
      
      isPlayingAudio = true;
      mainCircle.classList.add('speaking');
      mainCircle.classList.remove('listening', 'voice-switching');
      
      const audioBase64 = audioPlaybackQueue.shift();
      
      try {
        // Декодируем Base64 в ArrayBuffer
        const audioData = base64ToArrayBuffer(audioBase64);
        
        if (audioData.byteLength === 0) {
          playNextAudioIOS();
          return;
        }
        
        // Используем улучшенную функцию создания WAV
        const wavBuffer = createWavFromPcmMobile(audioData);
        if (!wavBuffer) {
          playNextAudioIOS();
          return;
        }
        
        const blob = new Blob([wavBuffer], { type: 'audio/wav' });
        const audioUrl = URL.createObjectURL(blob);
        
        // Получаем предактивированный Audio элемент
        const audio = getIOSAudioElement();
        
        // Добавляем в массив для отслеживания
        audioElements.push(audio);
        
        // Быстрая настройка без лишних проверок
        audio.preload = 'auto';
        audio.autoplay = false;
        audio.controls = false;
        audio.muted = false;
        
        // Немедленные обработчики
        const cleanup = () => {
          URL.revokeObjectURL(audioUrl);
          const index = audioElements.indexOf(audio);
          if (index > -1) {
            audioElements.splice(index, 1);
          }
          // Возвращаем элемент в пул для повторного использования
          if (iosAudioPool.length < 5) {
            audio.src = '';
            audio.load();
            iosAudioPool.push(audio);
          }
        };
        
        audio.onended = () => {
          cleanup();
          playNextAudioIOS();
        };
        
        audio.onerror = (e) => {
          log(`Ошибка iOS аудио: ${e.type}`, "error");
          cleanup();
          playNextAudioIOS();
        };
        
        // Агрессивная стратегия воспроизведения для iOS
        const attemptPlay = async () => {
          try {
            // Устанавливаем источник
            audio.src = audioUrl;
            
            // Ждем готовности
            if (audio.readyState < 3) { // HAVE_FUTURE_DATA
              await new Promise((resolve, reject) => {
                const onCanPlay = () => {
                  audio.removeEventListener('canplay', onCanPlay);
                  audio.removeEventListener('error', onError);
                  resolve();
                };
                const onError = () => {
                  audio.removeEventListener('canplay', onCanPlay);
                  audio.removeEventListener('error', onError);
                  reject(new Error('Загрузка аудио не удалась'));
                };
                audio.addEventListener('canplay', onCanPlay);
                audio.addEventListener('error', onError);
                audio.load();
              });
            }
            
            // Воспроизводим
            const playPromise = audio.play();
            if (playPromise) {
              await playPromise;
            }
            
            log("iOS аудио успешно воспроизводится");
            
          } catch (error) {
            log(`Ошибка воспроизведения iOS аудио: ${error.message}`, "error");
            
            // Если не удалось воспроизвести, пробуем эмулировать касание
            if (!iosUserInteractionCompleted) {
              log("Попытка эмуляции пользовательского взаимодействия...");
              
              // Эмулируем событие касания
              const touchEvent = new TouchEvent('touchend', {
                bubbles: true,
                cancelable: true,
                touches: [],
                targetTouches: [],
                changedTouches: []
              });
              
              document.dispatchEvent(touchEvent);
              
              // Пробуем снова через небольшую задержку
              setTimeout(() => {
                audio.play().catch(() => {
                  cleanup();
                  playNextAudioIOS();
                });
              }, 50);
            } else {
              cleanup();
              playNextAudioIOS();
            }
          }
        };
        
        // Запускаем воспроизведение
        attemptPlay();
        
      } catch (error) {
        log(`Критическая ошибка iOS воспроизведения: ${error.message}`, "error");
        playNextAudioIOS();
      }
    }
    
    // Улучшенная функция воспроизведения для мобильных устройств
    function playNextAudioMobile() {
      if (audioPlaybackQueue.length === 0) {
        isPlayingAudio = false;
        mainCircle.classList.remove('speaking');
        
        // Начинаем слушать снова
        setTimeout(() => {
          if (!isListening && !reconnecting) {
            startListening();
          }
        }, 300);
        return;
      }
      
      isPlayingAudio = true;
      mainCircle.classList.add('speaking');
      mainCircle.classList.remove('listening', 'voice-switching');
      
      const audioBase64 = audioPlaybackQueue.shift();
      
      try {
        // Декодируем Base64 в ArrayBuffer
        const audioData = base64ToArrayBuffer(audioBase64);
        
        if (audioData.byteLength === 0) {
          playNextAudioMobile();
          return;
        }
        
        // Используем улучшенную функцию создания WAV
        const wavBuffer = createWavFromPcmMobile(audioData);
        if (!wavBuffer) {
          playNextAudioMobile();
          return;
        }
        
        const blob = new Blob([wavBuffer], { type: 'audio/wav' });
        const audioUrl = URL.createObjectURL(blob);
        
        // Создаем Audio элемент с оптимизацией для мобильных
        const audio = new Audio();
        
        // Настройки для мобильных устройств
        audio.preload = 'auto';
        audio.controls = false;
        audio.autoplay = false;
        
        // Добавляем в массив для отслеживания
        audioElements.push(audio);
        
        // Обработчики событий
        audio.onloadeddata = function() {
          log("Аудио загружено, начинаем воспроизведение");
          
          // Проверяем, что аудио разблокировано
          if (!mobileAudioEnabled && isMobileDevice()) {
            log("Аудио не разблокировано на мобильном устройстве", "warn");
            // Показываем уведомление пользователю
            showNotification("Нажмите на экран для включения звука", false);
            
            // Добавляем обработчик клика для разблокировки
            const unlockHandler = async () => {
              await unlockAudioContext();
              document.removeEventListener('touchstart', unlockHandler);
              document.removeEventListener('click', unlockHandler);
              
              // Пытаемся воспроизвести снова
              audio.play().catch(err => {
                log(`Ошибка воспроизведения после разблокировки: ${err.message}`, "error");
                playNextAudioMobile();
              });
            };
            
            document.addEventListener('touchstart', unlockHandler, { once: true });
            document.addEventListener('click', unlockHandler, { once: true });
            return;
          }
          
          // Воспроизводим аудио
          const playPromise = audio.play();
          
          if (playPromise !== undefined) {
            playPromise
              .then(() => {
                log("Аудио успешно воспроизводится");
              })
              .catch(err => {
                log(`Ошибка воспроизведения: ${err.message}`, "error");
                
                // Если ошибка связана с политикой автовоспроизведения
                if (err.name === 'NotAllowedError') {
                  showNotification("Нажмите для включения звука", false);
                  
                  // Добавляем обработчик для пользовательского взаимодействия
                  const interactionHandler = () => {
                    audio.play().catch(e => log(`Повторная ошибка воспроизведения: ${e.message}`, "error"));
                    document.removeEventListener('touchstart', interactionHandler);
                    document.removeEventListener('click', interactionHandler);
                  };
                  
                  document.addEventListener('touchstart', interactionHandler, { once: true });
                  document.addEventListener('click', interactionHandler, { once: true });
                } else {
                  playNextAudioMobile();
                }
              });
          }
        };
        
        audio.onended = function() {
          URL.revokeObjectURL(audioUrl);
          // Удаляем из массива
          const index = audioElements.indexOf(audio);
          if (index > -1) {
            audioElements.splice(index, 1);
          }
          playNextAudioMobile();
        };
        
        audio.onerror = function(e) {
          log(`Ошибка аудио элемента: ${e.message || 'Неизвестная ошибка'}`, "error");
          URL.revokeObjectURL(audioUrl);
          // Удаляем из массива
          const index = audioElements.indexOf(audio);
          if (index > -1) {
            audioElements.splice(index, 1);
          }
          playNextAudioMobile();
        };
        
        audio.oncanplay = function() {
          log("Аудио готово к воспроизведению");
        };
        
        // Устанавливаем источник
        audio.src = audioUrl;
        
        // Загружаем аудио
        audio.load();
        
      } catch (error) {
        log(`Критическая ошибка воспроизведения: ${error.message}`, "error");
        playNextAudioMobile();
      }
    }
    
    // Добавить аудио в очередь воспроизведения
    function addAudioToPlaybackQueue(audioBase64) {
      if (!audioBase64 || typeof audioBase64 !== 'string') return;
      
      // Добавляем аудио в очередь
      audioPlaybackQueue.push(audioBase64);
      
      // Если не запущено воспроизведение, запускаем
      if (!isPlayingAudio) {
        playNextAudio();
      }
    }
    
    // Воспроизведение следующего аудио в очереди
    function playNextAudio() {
      if (audioPlaybackQueue.length === 0) {
        isPlayingAudio = false;
        // Сбрасываем эффект говорения, когда все аудио воспроизведено
        mainCircle.classList.remove('speaking');
        return;
      }
      
      isPlayingAudio = true;
      
      // Активируем визуальное состояние говорения
      mainCircle.classList.add('speaking');
      mainCircle.classList.remove('listening');
      mainCircle.classList.remove('voice-switching');
      
      const audioBase64 = audioPlaybackQueue.shift();
      
      try {
        // Декодируем Base64 в ArrayBuffer
        const audioData = base64ToArrayBuffer(audioBase64);
        
        // Проверяем размер данных
        if (audioData.byteLength === 0) {
          playNextAudio(); // Пропускаем пустой аудио-чанк
          return;
        }
        
        // Предполагаем, что данные в формате PCM16, конвертируем в WAV для воспроизведения
        const wavBuffer = createWavFromPcm(audioData);
        const blob = new Blob([wavBuffer], { type: 'audio/wav' });
        const audioUrl = URL.createObjectURL(blob);
        
        // Воспроизводим звук
        const audio = new Audio(audioUrl);
        
        audio.oncanplaythrough = function() {
          audio.play().catch(err => {
            log(`Ошибка при воспроизведении: ${err.message}`, "error");
            playNextAudio(); // В случае ошибки переходим к следующему аудио
          });
        };
        
        // После окончания воспроизведения
        audio.onended = function() {
          URL.revokeObjectURL(audioUrl);
          playNextAudio(); // Переходим к следующему аудио
        };
        
        // В случае ошибки
        audio.onerror = function() {
          URL.revokeObjectURL(audioUrl);
          playNextAudio(); // В случае ошибки переходим к следующему аудио
        };
      } catch (error) {
        log(`Ошибка воспроизведения аудио: ${error.message}`, "error");
        playNextAudio(); // В случае ошибки переходим к следующему аудио
      }
    }
    
    // Добавляем аудио в очередь для iOS
    function addAudioToPlaybackQueueIOS(audioBase64) {
      if (!audioBase64 || typeof audioBase64 !== 'string') {
        log("Некорректные аудио данные для iOS", "warn");
        return;
      }
      
      log(`Добавляем аудио в очередь iOS (размер: ${audioBase64.length} символов)`);
      
      audioPlaybackQueue.push(audioBase64);
      
      if (!isPlayingAudio) {
        playNextAudioIOS();
      }
    }
    
    // Обновленная функция добавления аудио в очередь для мобильных
    function addAudioToPlaybackQueueMobile(audioBase64) {
      if (!audioBase64 || typeof audioBase64 !== 'string') {
        log("Некорректные аудио данные", "warn");
        return;
      }
      
      log(`Добавляем аудио в очередь (размер: ${audioBase64.length} символов)`);
      
      audioPlaybackQueue.push(audioBase64);
      
      if (!isPlayingAudio) {
        playNextAudioMobile();
      }
    }
    
    // Добавление сообщения в чат (скрытое)
    function addMessage(text, isUser) {
      const messageElement = document.createElement('div');
      messageElement.className = `message ${isUser ? 'user-message' : 'assistant-message'}`;
      messageElement.textContent = text;
      messagesContainer.appendChild(messageElement);
    }
    
    // Подключение к WebSocket серверу
    async function connectWebSocket() {
      return new Promise((resolve, reject) => {
        try {
          loadingModal.classList.add('active');
          log("Подключение...");
          
          // Используем WebSocket-соединение с нашим локальным прокси
          const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
          const wsUrl = `${protocol}//${window.location.host}/ws`;
          // НЕ логируем информацию о URL соединения
          // log(`WebSocket URL: ${wsUrl}`);
          
          // Создаем новое WebSocket соединение
          websocket = new WebSocket(wsUrl);
          
          // Устанавливаем таймаут на открытие соединения
          const connectionTimeout = setTimeout(() => {
            log("Превышено время ожидания соединения", "error");
            websocket.close();
            reject(new Error("Таймаут соединения"));
          }, 15000);
          
          websocket.onopen = function() {
            clearTimeout(connectionTimeout);
            log("Соединение установлено");
            isConnected = true;
            loadingModal.classList.remove('active');
            
            // Обновляем сессию с выбранным голосом
            updateSessionSettings();
            
            // Автоматически начинаем слушать (всегда активно)
            startListening();
            
            resolve(true);
          };
          
          websocket.onmessage = function(event) {
            handleWebSocketMessage(event.data);
          };
          
          websocket.onclose = function(event) {
            log(`Соединение закрыто`, event.wasClean ? "info" : "error");
            isConnected = false;
            
            // Сбрасываем состояния
            isListening = false;
            isProcessing = false;
            reconnecting = false;
            audioCommitInProgress = false; // Добавляем сброс этого флага
            silenceDetectionActive = true;
            resetAudioState();
            
            // Пытаемся переподключиться, если соединение было разорвано не чисто
            if (!event.wasClean) {
              mainCircle.style.boxShadow = "0 0 30px rgba(244, 67, 54, 0.3)";
              
              setTimeout(() => {
                connectWebSocket().catch(err => {
                  log(`Ошибка при переподключении: ${err.message}`, "error");
                });
              }, 3000);
            }
            
            reject(new Error(`Соединение закрыто`));
          };
          
          websocket.onerror = function(error) {
            log(`Ошибка соединения`, "error");
            isConnected = false;
            reject(error);
          };
        } catch (error) {
          log(`Ошибка при установке соединения: ${error.message}`, "error");
          reject(error);
        }
      });
    }
    
    // Обновление настроек сессии на сервере
    function updateSessionSettings() {
      if (!isConnected || !websocket || websocket.readyState !== WebSocket.OPEN) {
        log("Невозможно обновить настройки: нет соединения", "warn");
        return;
      }
      
      try {
        log(`Отправка начальных настроек сессии с голосом ${userSettings.voice}`);
        
        // Отправляем обновление настроек
        const updateMessage = {
          type: "session.update",
          event_id: `settings_${Date.now()}`,
          session: {
            voice: userSettings.voice
          }
        };
        
        websocket.send(JSON.stringify(updateMessage));
      } catch (error) {
        log(`Ошибка при обновлении настроек: ${error.message}`, "error");
      }
    }
    
    // Обработка сообщений от сервера
    function handleWebSocketMessage(data) {
      try {
        // Если данные в бинарном формате, преобразуем их в текст
        if (data instanceof Blob) {
          const reader = new FileReader();
          reader.onload = function() {
            const text = reader.result;
            try {
              const json = JSON.parse(text);
              processServerEvent(json);
            } catch (e) {
              log(`Ошибка парсинга JSON из бинарных данных`, "error");
            }
          };
          reader.readAsText(data);
        } else {
          try {
            const json = typeof data === 'string' ? JSON.parse(data) : data;
            processServerEvent(json);
          } catch (e) {
            log(`Ошибка парсинга JSON из текстовых данных`, "error");
          }
        }
      } catch (error) {
        log(`Ошибка обработки сообщения`, "error");
      }
    }
    
    // Обработка событий от сервера
    let currentResponseText = "";
    let currentResponseId = null;
    let currentItemId = null;
    
    function processServerEvent(event) {
      if (!event || !event.type) return;
      
      // Логируем события для отладки на мобильных
      if (isMobileDevice()) {
        log(`Mobile event: ${event.type}`, "debug");
      }
      
      // Обработка события смены голоса
      if (event.type === "voice_changed") {
        const voiceName = event.voice_name || event.voice;
        
        if (event.success) {
          userSettings.voice = event.voice;
          voiceSelector.value = event.voice;
          log(`Голос успешно изменен на ${event.voice}`);
          
          if (event.ready) {
            showNotification(`Голос изменен на ${voiceName}`, false);
            reconnecting = false;
            mainCircle.classList.remove('voice-switching');
            
            setTimeout(() => {
              if (!isListening && !isProcessing) {
                startListening();
              }
            }, 500);
          }
        } else {
          log(`Ошибка смены голоса: ${event.error}`, "error");
          showNotification("Ошибка смены голоса", true);
          reconnecting = false;
          mainCircle.classList.remove('voice-switching');
        }
        return;
      }
      
      // Обрабатываем события коммита аудиобуфера
      handleAudioCommitResponse(event);
      
      switch (event.type) {
        case 'session.created':
          log("Сессия создана");
          break;
          
        case 'session.updated':
          log("Настройки сессии обновлены");
          break;
          
        case 'input_audio_buffer.speech_started':
          log("Начало речи");
          break;
          
        case 'input_audio_buffer.speech_stopped':
          log("Конец речи");
          break;
          
        case 'conversation.item.created':
          if (event.item && event.item.content) {
            currentItemId = event.item.id;
            log(`Элемент диалога создан: ${event.item.id}`);
          }
          break;
          
        case 'response.created':
          currentResponseId = event.response.id;
          currentResponseText = "";
          log(`Ответ создан: ${event.response.id}`);
          break;
          
        case 'response.output_item.added':
          log("Элемент ответа добавлен");
          break;
          
        case 'response.content_part.added':
          log("Часть контента добавлена");
          break;
          
        case 'response.audio.delta':
          if (event.delta) {
            // Добавляем аудио в очередь воспроизведения
            if (isIOS()) {
              addAudioToPlaybackQueueIOS(event.delta);
            } else if (isMobileDevice()) {
              addAudioToPlaybackQueueMobile(event.delta);
            } else {
              addAudioToPlaybackQueue(event.delta);
            }
          }
          break;
          
        case 'response.audio.done':
          log("Аудио ответ завершен");
          break;
          
        case 'response.text.delta':
          if (event.delta) {
            currentResponseText += event.delta;
            transcriptElement.textContent = currentResponseText;
          }
          break;
          
        case 'response.text.done':
          if (event.text) {
            addMessage(event.text, false);
            transcriptElement.textContent = "";
          }
          break;
          
        case 'response.done':
          log("Ответ полностью завершен");
          isProcessing = false;
          break;
          
        case 'error':
          log(`Ошибка от сервера: ${event.error ? event.error.message : 'Неизвестная ошибка'}`, "error");
          
          // Специальная обработка ошибки "buffer too small"
          if (event.error && event.error.message && event.error.message.includes("buffer too small")) {
            log("Ошибка пустого буфера - продолжаем работу");
          } else {
            showNotification(event.error ? event.error.message : "Произошла ошибка", true);
          }
          
          isProcessing = false;
          audioCommitInProgress = false;
          silenceDetectionActive = true;
          resetAudioState();
          
          // Перезапускаем слушание после ошибки
          setTimeout(() => {
            if (!isListening && !reconnecting) {
              startListening();
            }
          }, 1000);
          break;
          
        default:
          // Логируем неизвестные события для отладки
          if (isMobileDevice()) {
            log(`Неизвестное событие: ${event.type}`, "debug");
          }
          break;
      }
    }
    
    // Начать прослушивание
    async function startListening() {
      if (isListening || isProcessing || reconnecting || !isConnected) {
        log("Невозможно начать слушание: неподходящие условия", "warn");
        return;
      }
      
      try {
        // Инициализируем аудио, если еще не сделали
        if (!audioContext || !mediaStream || !audioProcessor) {
          let audioInitialized = false;
          
          if (isMobileDevice()) {
            audioInitialized = await initAudioMobileFixed();
          } else {
            audioInitialized = await initAudioFixed();
          }
          
          if (!audioInitialized) {
            log("Не удалось инициализировать аудио", "error");
            return;
          }
        }
        
        // Активируем аудио для iOS если нужно
        if (isIOS() && !iosAudioFullyUnlocked) {
          await universalIOSAudioUnlock();
        }
        
        // Возобновляем AudioContext если приостановлен
        if (audioContext && audioContext.state === 'suspended') {
          await audioContext.resume();
        }
        
        isListening = true;
        
        // Визуальная обратная связь
        mainCircle.classList.add('listening');
        mainCircle.classList.remove('speaking', 'voice-switching');
        
        // Сбрасываем состояние аудио
        resetAudioState();
        audioCommitInProgress = false;
        silenceDetectionActive = true;
        
        log("Прослушивание активировано");
        
      } catch (error) {
        log(`Ошибка при запуске прослушивания: ${error.message}`, "error");
        showNotification("Ошибка при запуске микрофона", true);
        isListening = false;
        mainCircle.classList.remove('listening');
      }
    }
    
    // Остановить прослушивание
    function stopListening() {
      if (!isListening) return;
      
      isListening = false;
      
      // Визуальная обратная связь
      mainCircle.classList.remove('listening');
      resetAudioVisualization();
      
      // Очищаем таймаут буфера
      if (audioBufferTimeoutId) {
        clearTimeout(audioBufferTimeoutId);
        audioBufferTimeoutId = null;
      }
      
      // Сбрасываем состояние
      resetAudioState();
      audioCommitInProgress = false;
      silenceDetectionActive = true;
      
      log("Прослушивание остановлено");
    }
    
    // Применить и определить типы устройств
    function applyDeviceSpecificStyles() {
      const body = document.body;
      
      if (isMobileDevice()) {
        body.classList.add('mobile-device');
      }
      
      if (isIOS()) {
        body.classList.add('ios-device');
      }
      
      log(`Устройство: ${isMobileDevice() ? 'мобильное' : 'десктоп'}, iOS: ${isIOS()}`);
    }
    
    // Обработчик кликов по главному кругу
    function handleMainCircleClick() {
      // Активируем аудио для мобильных устройств
      if (isMobileDevice()) {
        enableAudioOnUserInteraction();
        
        // Для iOS дополнительно активируем аудио
        if (isIOS()) {
          universalIOSAudioUnlock();
        }
      }
      
      // Если не подключены - пытаемся подключиться
      if (!isConnected) {
        connectWebSocket().catch(err => {
          log(`Ошибка подключения: ${err.message}`, "error");
          showNotification("Ошибка подключения к серверу", true);
        });
        return;
      }
      
      // Если сейчас происходит смена голоса - игнорируем клик
      if (reconnecting) {
        log("Клик игнорирован: происходит смена голоса", "info");
        return;
      }
      
      // Если не слушаем - начинаем слушать
      if (!isListening && !isProcessing) {
        startListening();
      }
    }
    
    // Обработчики настроек
    function setupSettingsHandlers() {
      // Открытие настроек
      settingsButton.addEventListener('click', () => {
        settingsModal.classList.add('active');
        voiceSelector.value = userSettings.voice;
      });
      
      // Закрытие настроек (отмена)
      settingsCancel.addEventListener('click', () => {
        settingsModal.classList.remove('active');
        voiceSelector.value = userSettings.voice; // Восстанавливаем значение
      });
      
      // Сохранение настроек
      settingsSave.addEventListener('click', () => {
        const newVoice = voiceSelector.value;
        
        if (newVoice !== userSettings.voice) {
          changeVoice(newVoice);
        }
        
        settingsModal.classList.remove('active');
      });
      
      // Закрытие модального окна по клику вне его
      settingsModal.addEventListener('click', (e) => {
        if (e.target === settingsModal) {
          settingsModal.classList.remove('active');
          voiceSelector.value = userSettings.voice; // Восстанавливаем значение
        }
      });
    }
    
    // Смена голоса
    function changeVoice(newVoice) {
      if (!isConnected || reconnecting) {
        log("Невозможно сменить голос: нет соединения или уже происходит смена", "warn");
        return;
      }
      
      log(`Смена голоса с ${userSettings.voice} на ${newVoice}`);
      
      reconnecting = true;
      
      // Останавливаем прослушивание
      stopListening();
      
      // Очищаем очередь воспроизведения
      audioPlaybackQueue = [];
      isPlayingAudio = false;
      
      // Визуальное состояние переключения
      mainCircle.classList.remove('listening', 'speaking');
      mainCircle.classList.add('voice-switching');
      
      try {
        // Отправляем команду смены голоса на сервер
        websocket.send(JSON.stringify({
          type: "change_voice",
          voice: newVoice,
          event_id: `voice_change_${Date.now()}`
        }));
        
        showNotification(`Переключение на голос ${newVoice}...`, false);
        
      } catch (error) {
        log(`Ошибка при смене голоса: ${error.message}`, "error");
        showNotification("Ошибка смены голоса", true);
        reconnecting = false;
        mainCircle.classList.remove('voice-switching');
        
        // Возвращаем к прослушиванию
        setTimeout(() => {
          if (!isListening && !isProcessing) {
            startListening();
          }
        }, 500);
      }
    }
    
    // Очистка ресурсов при закрытии
    function cleanup() {
      // Останавливаем все аудио элементы
      audioElements.forEach(audio => {
        try {
          audio.pause();
          audio.src = '';
        } catch (e) {
          // Игнорируем ошибки при очистке
        }
      });
      audioElements = [];
      
      // Очищаем iOS аудио пул
      iosAudioPool.forEach(audio => {
        try {
          audio.pause();
          audio.src = '';
        } catch (e) {
          // Игнорируем ошибки при очистке
        }
      });
      iosAudioPool = [];
      
      // Закрываем медиа поток
      if (mediaStream) {
        mediaStream.getTracks().forEach(track => track.stop());
      }
      
      // Закрываем AudioContext
      if (audioContext) {
        audioContext.close().catch(() => {});
      }
      
      // Закрываем WebSocket
      if (websocket) {
        websocket.close();
      }
      
      log("Ресурсы очищены");
    }
    
    // Инициализация приложения
    async function initializeApp() {
      try {
        log("Инициализация WellcomeAI...");
        
        // Применяем стили для устройства
        applyDeviceSpecificStyles();
        
        // Настраиваем обработчики
        setupSettingsHandlers();
        
        // Обработчик клика по главному кругу
        mainCircle.addEventListener('click', handleMainCircleClick);
        mainCircle.addEventListener('touchend', handleMainCircleClick);
        
        // Для мобильных устройств добавляем обработчики активации аудио
        if (isMobileDevice()) {
          document.addEventListener('touchstart', enableAudioOnUserInteraction, { once: true });
          document.addEventListener('click', enableAudioOnUserInteraction, { once: true });
          
          // Для iOS дополнительная активация
          if (isIOS()) {
            document.addEventListener('touchend', universalIOSAudioUnlock, { once: true });
          }
        }
        
        // Обработчик закрытия страницы
        window.addEventListener('beforeunload', cleanup);
        window.addEventListener('unload', cleanup);
        
        // Обработчик изменения видимости страницы
        document.addEventListener('visibilitychange', () => {
          if (document.hidden) {
            // Страница скрыта - приостанавливаем
            if (audioContext && audioContext.state === 'running') {
              audioContext.suspend().catch(() => {});
            }
          } else {
            // Страница видима - возобновляем
            if (audioContext && audioContext.state === 'suspended') {
              audioContext.resume().catch(() => {});
            }
          }
        });
        
        // Пытаемся подключиться к серверу
        try {
          await connectWebSocket();
          log("Инициализация завершена успешно");
          
          // Показываем уведомление о готовности для мобильных
          if (isMobileDevice()) {
            showNotification("Нажмите на круг для активации голосового общения", false);
          }
          
        } catch (error) {
          log(`Ошибка подключения при инициализации: ${error.message}`, "error");
          loadingModal.classList.remove('active');
          showNotification("Ошибка подключения к серверу. Проверьте соединение.", true);
          
          // Показываем кнопку для повторной попытки
          mainCircle.style.cursor = 'pointer';
          mainCircle.title = 'Нажмите для подключения';
        }
        
      } catch (error) {
        log(`Критическая ошибка инициализации: ${error.message}`, "error");
        loadingModal.classList.remove('active');
        showNotification("Критическая ошибка инициализации", true);
      }
    }
    
    // Обработчик изменения ориентации для мобильных
    if (isMobileDevice()) {
      window.addEventListener('orientationchange', () => {
        setTimeout(() => {
          // Пересчитываем размеры после поворота
          if (audioContext && audioContext.state === 'suspended') {
            audioContext.resume().catch(() => {});
          }
        }, 100);
      });
    }
    
    // Запускаем приложение после полной загрузки DOM
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initializeApp);
    } else {
      initializeApp();
    }
    
    // Экспортируем функции для глобального доступа (для отладки)
    window.WellcomeAI = {
      log,
      showNotification,
      startListening,
      stopListening,
      changeVoice,
      cleanup,
      getConnectionStatus: () => isConnected,
      getListeningStatus: () => isListening,
      getProcessingStatus: () => isProcessing,
      getCurrentVoice: () => userSettings.voice
    };
    
    log("WellcomeAI загружен и готов к работе");
    
  </script>
</body>
</html>
