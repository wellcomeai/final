<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>WellcomeAI - Голосовой помощник</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <style>
    /* Reset и базовые стили */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      font-family: 'Segoe UI', 'Roboto', sans-serif;
    }
    
    body {
      background-color: #ffffff;
      color: #333;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      overflow-x: hidden;
    }
    
    /* Главный контейнер */
    .container {
      width: 100%;
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    
    /* Заголовок */
    .header {
      text-align: center;
      margin-bottom: 30px;
      width: 100%;
      position: relative;
    }
    
    .logo {
      font-size: 28px;
      color: #4a86e8;
      font-weight: 600;
    }
    
    /* Настройки */
    .settings-button {
      position: absolute;
      right: 0;
      top: 5px;
      background: none;
      border: none;
      color: #777;
      font-size: 20px;
      cursor: pointer;
      opacity: 0.7;
      transition: opacity 0.3s, transform 0.3s;
    }
    
    .settings-button:hover {
      opacity: 1;
      transform: rotate(30deg);
    }
    
    /* Основной элемент - круг */
    .main-circle-container {
      position: relative;
      width: 100%;
      display: flex;
      justify-content: center;
      margin-bottom: 20px;
    }
    
    .main-circle {
      width: 280px;
      height: 280px;
      border-radius: 50%;
      background: linear-gradient(135deg, #ffffff, #e1f5fe, #4a86e8);
      box-shadow: 0 10px 20px rgba(0, 0, 0, 0.1);
      position: relative;
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s ease;
    }
    
    .main-circle::before {
      content: '';
      position: absolute;
      width: 140%;
      height: 140%;
      background: linear-gradient(45deg, rgba(255, 255, 255, 0.3), rgba(74, 134, 232, 0.2));
      animation: wave 8s linear infinite;
      border-radius: 40%;
    }
    
    @keyframes wave {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    .activation-button {
      position: absolute;
      right: -40px;
      top: 50%;
      transform: translateY(-50%);
      width: 48px;
      height: 48px;
      border-radius: 8px;
      background-color: #1a237e;
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
      cursor: pointer;
      box-shadow: 0 3px 5px rgba(0, 0, 0, 0.2);
      transition: all 0.3s ease;
    }
    
    .activation-button:hover {
      background-color: #283593;
      transform: translateY(-50%) scale(1.05);
    }
    
    /* Аудио визуализация */
    .audio-visualization {
      width: 100%;
      max-width: 400px;
      height: 60px;
      margin: 0 auto 20px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .audio-bars {
      display: flex;
      align-items: flex-end;
      height: 40px;
      gap: 3px;
      width: 100%;
      justify-content: center;
    }
    
    .audio-bar {
      width: 4px;
      height: 2px;
      background-color: #4a86e8;
      border-radius: 2px;
      transition: height 0.1s ease;
    }
    
    /* Транскрипция */
    .transcript {
      font-style: italic;
      margin: 10px 0;
      color: #666;
      text-align: center;
      min-height: 24px;
      font-size: 16px;
    }
    
    /* Чат */
    .chat-container {
      width: 100%;
      max-width: 800px;
      background-color: #f8f9fa;
      border-radius: 16px;
      overflow: hidden;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
      margin: 0 auto;
      display: flex;
      flex-direction: column;
      height: calc(100vh - 500px);
      min-height: 300px;
    }
    
    .messages {
      flex: 1;
      overflow-y: auto;
      padding: 20px;
      display: flex;
      flex-direction: column;
    }
    
    .message {
      max-width: 80%;
      padding: 12px 16px;
      margin-bottom: 15px;
      border-radius: 18px;
      position: relative;
      animation: messageAppear 0.3s ease;
      line-height: 1.5;
    }
    
    @keyframes messageAppear {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }
    
    .user-message {
      background-color: #e3f2fd;
      color: #333;
      align-self: flex-end;
      border-bottom-right-radius: 4px;
    }
    
    .assistant-message {
      background-color: white;
      color: #333;
      align-self: flex-start;
      border-bottom-left-radius: 4px;
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
    }
    
    /* Область ввода */
    .input-area {
      display: flex;
      padding: 15px;
      background-color: white;
      border-top: 1px solid #eee;
    }
    
    #text-input {
      flex: 1;
      padding: 12px 20px;
      border: 1px solid #ddd;
      border-radius: 24px;
      background-color: #f5f5f5;
      color: #333;
      font-size: 16px;
      outline: none;
      transition: all 0.2s;
    }
    
    #text-input:focus {
      border-color: #4a86e8;
      background-color: #fff;
      box-shadow: 0 0 0 2px rgba(74, 134, 232, 0.2);
    }
    
    .voice-button {
      width: 48px;
      height: 48px;
      border-radius: 50%;
      background-color: #4a86e8;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-left: 10px;
      cursor: pointer;
      border: none;
      color: white;
      transition: all 0.2s;
    }
    
    .voice-button:hover {
      background-color: #3b78e7;
      transform: scale(1.05);
    }
    
    .voice-button.listening {
      animation: pulse 1.5s infinite;
      background-color: #f44336;
    }
    
    @keyframes pulse {
      0% { transform: scale(1); box-shadow: 0 0 0 0 rgba(244, 67, 54, 0.4); }
      70% { transform: scale(1.05); box-shadow: 0 0 0 10px rgba(244, 67, 54, 0); }
      100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(244, 67, 54, 0); }
    }
    
    /* Статус */
    .status {
      text-align: center;
      margin-top: 15px;
      font-size: 14px;
      color: #777;
    }
    
    /* Модальное окно */
    .modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      opacity: 0;
      visibility: hidden;
      transition: all 0.3s;
    }
    
    .modal.active {
      opacity: 1;
      visibility: visible;
    }
    
    .modal-content {
      background-color: white;
      padding: 30px;
      border-radius: 16px;
      max-width: 500px;
      width: 100%;
      text-align: center;
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
      transform: scale(0.9);
      transition: transform 0.3s;
    }
    
    .modal.active .modal-content {
      transform: scale(1);
    }
    
    .modal h2 {
      color: #4a86e8;
      margin-top: 0;
      margin-bottom: 20px;
    }
    
    .modal p {
      margin-bottom: 20px;
      color: #555;
    }
    
    /* Модальное окно загрузки */
    .spinner {
      display: inline-block;
      width: 50px;
      height: 50px;
      border: 3px solid rgba(74, 134, 232, 0.3);
      border-radius: 50%;
      border-top-color: #4a86e8;
      animation: spin 1s linear infinite;
      margin-bottom: 20px;
    }
    
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    
    /* Модальное окно настроек */
    .settings-modal .modal-content {
      text-align: left;
    }
    
    .settings-group {
      margin-bottom: 20px;
    }
    
    .settings-group h3 {
      margin-bottom: 10px;
      font-size: 18px;
      color: #333;
    }
    
    .settings-option {
      margin-bottom: 15px;
    }
    
    .settings-option label {
      display: block;
      margin-bottom: 5px;
      color: #555;
    }
    
    .settings-voice-selector {
      width: 100%;
      padding: 10px;
      border-radius: 8px;
      border: 1px solid #ddd;
      font-size: 16px;
    }
    
    .toggle-switch {
      position: relative;
      display: inline-block;
      width: 50px;
      height: 26px;
    }
    
    .toggle-switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }
    
    .slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #ccc;
      transition: .4s;
      border-radius: 34px;
    }
    
    .slider:before {
      position: absolute;
      content: "";
      height: 18px;
      width: 18px;
      left: 4px;
      bottom: 4px;
      background-color: white;
      transition: .4s;
      border-radius: 50%;
    }
    
    input:checked + .slider {
      background-color: #4a86e8;
    }
    
    input:checked + .slider:before {
      transform: translateX(24px);
    }
    
    .setting-buttons {
      display: flex;
      justify-content: flex-end;
      margin-top: 20px;
    }
    
    .setting-button {
      padding: 10px 20px;
      border: none;
      border-radius: 8px;
      font-size: 16px;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .setting-button.cancel {
      background-color: #f5f5f5;
      color: #333;
      margin-right: 10px;
    }
    
    .setting-button.save {
      background-color: #4a86e8;
      color: white;
    }
    
    .setting-button:hover {
      opacity: 0.9;
    }
    
    /* Отладочная панель */
    .debug-panel {
      background-color: white;
      border-radius: 8px;
      padding: 15px;
      margin-top: 20px;
      border: 1px solid #eee;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
      display: none;
      width: 100%;
    }
    
    .debug-log {
      max-height: 200px;
      overflow-y: auto;
      font-family: monospace;
      font-size: 12px;
      background-color: #f8f9fa;
      padding: 10px;
      border-radius: 5px;
      border: 1px solid #eee;
    }
    
    .log-entry {
      margin-bottom: 5px;
      line-height: 1.4;
    }
    
    .log-info { color: #4a86e8; }
    .log-error { color: #f44336; }
    .log-warn { color: #ff9800; }
    .log-debug { color: #777; }
    
    /* Мобильная версия */
    @media (max-width: 768px) {
      .container {
        padding: 15px;
      }
      
      .logo {
        font-size: 24px;
      }
      
      .main-circle {
        width: 220px;
        height: 220px;
      }
      
      .activation-button {
        right: -30px;
        width: 40px;
        height: 40px;
        font-size: 16px;
      }
      
      .chat-container {
        height: calc(100vh - 400px);
        min-height: 250px;
      }
      
      .message {
        max-width: 90%;
        font-size: 15px;
      }
      
      #text-input {
        padding: 10px 15px;
      }
      
      .voice-button {
        width: 42px;
        height: 42px;
      }
    }
    
    @media (max-width: 480px) {
      .main-circle {
        width: 180px;
        height: 180px;
      }
      
      .activation-button {
        right: -25px;
        width: 36px;
        height: 36px;
        font-size: 14px;
      }
      
      .chat-container {
        height: calc(100vh - 350px);
      }
    }
  </style>
</head>
<body>
  <!-- Модальное окно загрузки -->
  <div id="loading-modal" class="modal active">
    <div class="modal-content">
      <div class="spinner"></div>
      <h2>Подключение к WellcomeAI...</h2>
      <p>Пожалуйста, подождите. Это может занять несколько секунд.</p>
      <div id="loading-status">Инициализация...</div>
    </div>
  </div>
  
  <!-- Модальное окно настроек -->
  <div id="settings-modal" class="modal settings-modal">
    <div class="modal-content">
      <h2>Настройки</h2>
      
      <div class="settings-group">
        <h3>Голос ассистента</h3>
        <div class="settings-option">
          <label for="voice-selector">Выберите голос:</label>
          <select id="voice-selector" class="settings-voice-selector">
            <option value="alloy">Alloy (по умолчанию)</option>
            <option value="echo">Echo</option>
            <option value="fable">Fable</option>
            <option value="onyx">Onyx</option>
            <option value="nova">Nova</option>
            <option value="shimmer">Shimmer</option>
          </select>
        </div>
      </div>
      
      <div class="settings-group">
        <h3>Режим работы</h3>
        <div class="settings-option">
          <label for="always-listen-toggle">Постоянное прослушивание:</label>
          <label class="toggle-switch">
            <input type="checkbox" id="always-listen-toggle" checked>
            <span class="slider"></span>
          </label>
          <p style="margin-top: 5px; font-size: 13px; color: #777;">Если включено, микрофон будет активен постоянно без необходимости нажатия кнопки.</p>
        </div>
      </div>
      
      <div class="setting-buttons">
        <button class="setting-button cancel" id="settings-cancel">Отмена</button>
        <button class="setting-button save" id="settings-save">Сохранить</button>
      </div>
    </div>
  </div>

  <div class="container">
    <div class="header">
      <h1 class="logo">WellcomeAI</h1>
      <button class="settings-button" id="settings-button">
        <i class="fas fa-cog"></i>
      </button>
    </div>
    
    <div class="main-circle-container">
      <div class="main-circle" id="main-circle"></div>
      <div class="activation-button" id="activation-button">
        <i class="fas fa-terminal"></i>
      </div>
    </div>
    
    <div class="audio-visualization" id="audio-visualization">
      <div class="audio-bars" id="audio-bars">
        <!-- Аудио-бары будут добавлены с помощью JavaScript -->
      </div>
    </div>
    
    <div class="transcript" id="transcript"></div>
    
    <div class="chat-container">
      <div class="messages" id="messages">
        <div class="message assistant-message">
          Здравствуйте! Я WellcomeAI, ваш голосовой помощник. Чем могу помочь?
        </div>
      </div>
      
      <div class="input-area">
        <input type="text" id="text-input" placeholder="Введите сообщение...">
        <button class="voice-button" id="voice-button">
          <i class="fas fa-microphone"></i>
        </button>
      </div>
    </div>
    
    <div class="status" id="status">Не подключено</div>
    
    <!-- Отладочная панель, скрыта по умолчанию -->
    <div class="debug-panel" id="debug-panel">
      <h3>Отладочная информация</h3>
      <div class="debug-log" id="debug-log"></div>
    </div>
  </div>

  <script>
    // НАСТРОЙКИ
    
    // Включить режим отладки (true - включить, false - выключить)
    const DEBUG_MODE = true;
    
    // Элементы UI
    const voiceButton = document.getElementById('voice-button');
    const mainCircle = document.getElementById('main-circle');
    const activationButton = document.getElementById('activation-button');
    const textInput = document.getElementById('text-input');
    const messagesContainer = document.getElementById('messages');
    const statusElement = document.getElementById('status');
    const transcriptElement = document.getElementById('transcript');
    const loadingModal = document.getElementById('loading-modal');
    const loadingStatus = document.getElementById('loading-status');
    const audioBars = document.getElementById('audio-bars');
    const debugPanel = document.getElementById('debug-panel');
    const debugLog = document.getElementById('debug-log');
    
    // Элементы настроек
    const settingsButton = document.getElementById('settings-button');
    const settingsModal = document.getElementById('settings-modal');
    const settingsSave = document.getElementById('settings-save');
    const settingsCancel = document.getElementById('settings-cancel');
    const voiceSelector = document.getElementById('voice-selector');
    const alwaysListenToggle = document.getElementById('always-listen-toggle');
    
    // Включение отладочной панели, если режим отладки активен
    if (DEBUG_MODE) {
      debugPanel.style.display = 'block';
    }
    
    // Настройки пользователя
    let userSettings = {
      voice: "alloy",
      alwaysListen: true,
    };
    
    // Функция логирования
    function log(message, level = 'info') {
      const timestamp = new Date().toLocaleTimeString();
      console.log(`[${level.toUpperCase()}] ${message}`);
      
      if (DEBUG_MODE) {
        const logEntry = document.createElement('div');
        logEntry.className = `log-entry log-${level}`;
        logEntry.textContent = `[${timestamp}] ${message}`;
        debugLog.appendChild(logEntry);
        debugLog.scrollTop = debugLog.scrollHeight;
      }
      
      // Обновляем статус загрузки, если это информационное сообщение
      if (level === 'info' && loadingModal.classList.contains('active')) {
        loadingStatus.textContent = message;
      }
    }
    
    // Создаем аудио-бары для визуализации
    function createAudioBars(count = 30) {
      audioBars.innerHTML = '';
      for (let i = 0; i < count; i++) {
        const bar = document.createElement('div');
        bar.className = 'audio-bar';
        audioBars.appendChild(bar);
      }
    }
    createAudioBars();
    
    // Состояние
    let isConnected = false;
    let isListening = false;
    let isProcessing = false;
    let websocket = null;
    let audioContext = null;
    let mediaStream = null;
    let audioProcessor = null;
    
    // Создаем тестовый аудио-элемент для проверки форматов
    const audioTestElement = new Audio();
    
    // Инициализация микрофона и AudioContext
    async function initAudio() {
      try {
        log("Запрос разрешения на доступ к микрофону...");
        
        // Проверяем поддержку getUserMedia
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
          throw new Error("Ваш браузер не поддерживает доступ к микрофону");
        }
        
        // Запрашиваем доступ к микрофону
        mediaStream = await navigator.mediaDevices.getUserMedia({ 
          audio: {
            echoCancellation: true,
            noiseSuppression: true,
            autoGainControl: true,
            sampleRate: 24000
          } 
        });
        
        log("Доступ к микрофону получен");
        
        // Создаем AudioContext с нужной частотой дискретизации
        audioContext = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 24000 });
        log(`AudioContext создан с частотой ${audioContext.sampleRate} Гц`);
        
        // Создаем обработчик аудиопотока
        const streamSource = audioContext.createMediaStreamSource(mediaStream);
        
        // Выбираем размер буфера
        const bufferSize = 4096;
        
        // Проверяем, доступен ли ScriptProcessorNode
        if (audioContext.createScriptProcessor) {
          audioProcessor = audioContext.createScriptProcessor(bufferSize, 1, 1);
          log("Создан ScriptProcessorNode для обработки аудио");
        } else {
          throw new Error("Ваш браузер не поддерживает ScriptProcessorNode");
        }
        
        // Обработчик аудио
        audioProcessor.onaudioprocess = function(e) {
          if (isListening && websocket && websocket.readyState === WebSocket.OPEN) {
            // Получаем данные с микрофона
            const inputData = e.inputBuffer.getChannelData(0);
            
            // Проверяем, есть ли звук (чтобы не отправлять тишину)
            let hasSound = false;
            let maxAmplitude = 0;
            
            for (let i = 0; i < inputData.length; i++) {
              const absValue = Math.abs(inputData[i]);
              maxAmplitude = Math.max(maxAmplitude, absValue);
              if (absValue > 0.01) { // Порог обнаружения звука
                hasSound = true;
                break;
              }
            }
            
            // Обновляем визуализацию в любом случае
            updateAudioVisualization(inputData);
            
            // Отправляем только если есть звук или если прошло определенное время
            if (hasSound) {
              // Преобразуем float32 в int16
              const pcm16Data = new Int16Array(inputData.length);
              for (let i = 0; i < inputData.length; i++) {
                // Конвертируем float32 (-1.0 до 1.0) в int16 (-32768 до 32767)
                pcm16Data[i] = Math.max(-32768, Math.min(32767, Math.floor(inputData[i] * 32767)));
              }
              
              // Отправляем данные через WebSocket
              try {
                const message = JSON.stringify({
                  type: "input_audio_buffer.append",
                  event_id: `audio_${Date.now()}`,
                  audio: arrayBufferToBase64(pcm16Data.buffer)
                });
                
                websocket.send(message);
              } catch (error) {
                log(`Ошибка отправки аудио: ${error.message}`, "error");
              }
            }
          }
        };
        
        // Подключаем обработчик
        streamSource.connect(audioProcessor);
        audioProcessor.connect(audioContext.destination);
        
        log("Аудио инициализировано успешно");
        return true;
      } catch (error) {
        log(`Ошибка инициализации аудио: ${error.message}`, "error");
        statusElement.textContent = "Ошибка доступа к микрофону";
        return false;
      }
    }
    
    // Преобразование ArrayBuffer в Base64
    function arrayBufferToBase64(buffer) {
      const bytes = new Uint8Array(buffer);
      let binary = '';
      for (let i = 0; i < bytes.byteLength; i++) {
        binary += String.fromCharCode(bytes[i]);
      }
      return btoa(binary);
    }
    
    // Преобразование Base64 в ArrayBuffer
    function base64ToArrayBuffer(base64) {
      try {
        const binaryString = atob(base64);
        const bytes = new Uint8Array(binaryString.length);
        for (let i = 0; i < binaryString.length; i++) {
          bytes[i] = binaryString.charCodeAt(i);
        }
        return bytes.buffer;
      } catch (e) {
        log(`Ошибка при декодировании base64: ${e.message}`, "error");
        return new ArrayBuffer(0);
      }
    }
    
    // Обновление визуализации аудио
    function updateAudioVisualization(audioData) {
      const bars = audioBars.querySelectorAll('.audio-bar');
      const step = Math.floor(audioData.length / bars.length);
      
      for (let i = 0; i < bars.length; i++) {
        // Вычисляем среднее значение амплитуды для этого "отрезка" аудиоданных
        let sum = 0;
        for (let j = 0; j < step; j++) {
          const index = i * step + j;
          if (index < audioData.length) {
            sum += Math.abs(audioData[index]);
          }
        }
        const average = sum / step;
        
        // Нормализуем значение для высоты полосы (от 2px до 40px)
        const height = 2 + Math.min(38, Math.floor(average * 100));
        bars[i].style.height = `${height}px`;
      }
    }
    
    // Сброс визуализации аудио
    function resetAudioVisualization() {
      const bars = audioBars.querySelectorAll('.audio-bar');
      bars.forEach(bar => {
        bar.style.height = '2px';
      });
    }
    
    // Создаём простой WAV из PCM данных
    function createWavFromPcm(pcmBuffer, sampleRate = 24000) {
      // Создаём заголовок WAV
      const wavHeader = new ArrayBuffer(44);
      const view = new DataView(wavHeader);
      
      // "RIFF" chunk descriptor
      view.setUint8(0, 'R'.charCodeAt(0));
      view.setUint8(1, 'I'.charCodeAt(0));
      view.setUint8(2, 'F'.charCodeAt(0));
      view.setUint8(3, 'F'.charCodeAt(0));
      
      view.setUint32(4, 36 + pcmBuffer.byteLength, true); // Размер всего файла - 8
      
      // "WAVE" формат
      view.setUint8(8, 'W'.charCodeAt(0));
      view.setUint8(9, 'A'.charCodeAt(0));
      view.setUint8(10, 'V'.charCodeAt(0));
      view.setUint8(11, 'E'.charCodeAt(0));
      
      // "fmt " субчанк
      view.setUint8(12, 'f'.charCodeAt(0));
      view.setUint8(13, 'm'.charCodeAt(0));
      view.setUint8(14, 't'.charCodeAt(0));
      view.setUint8(15, ' '.charCodeAt(0));
      
      view.setUint32(16, 16, true); // Размер fmt субчанка
      view.setUint16(20, 1, true);  // Формат аудио (1 = PCM)
      view.setUint16(22, 1, true);  // Число каналов (1 = моно)
      view.setUint32(24, sampleRate, true); // Частота дискретизации
      view.setUint32(28, sampleRate * 2, true); // Байт в секунду (SampleRate * NumChannels * BitsPerSample/8)
      view.setUint16(32, 2, true);  // Байт на сэмпл (NumChannels * BitsPerSample/8)
      view.setUint16(34, 16, true); // Бит на сэмпл
      
      // "data" субчанк
      view.setUint8(36, 'd'.charCodeAt(0));
      view.setUint8(37, 'a'.charCodeAt(0));
      view.setUint8(38, 't'.charCodeAt(0));
      view.setUint8(39, 'a'.charCodeAt(0));
      
      view.setUint32(40, pcmBuffer.byteLength, true); // Размер данных
      
      // Объединяем заголовок и PCM данные
      const wavBuffer = new ArrayBuffer(wavHeader.byteLength + pcmBuffer.byteLength);
      const wavBytes = new Uint8Array(wavBuffer);
      
      wavBytes.set(new Uint8Array(wavHeader), 0);
      wavBytes.set(new Uint8Array(pcmBuffer), wavHeader.byteLength);
      
      return wavBuffer;
    }
    
    // Воспроизведение аудио из Base64
    function playAudio(audioBase64) {
      try {
        // Проверяем непустую строку
        if (!audioBase64 || typeof audioBase64 !== 'string') {
          log("Получены пустые аудио данные", "warn");
          return;
        }
        
        // Декодируем Base64 в ArrayBuffer
        const audioData = base64ToArrayBuffer(audioBase64);
        
        // Проверяем размер данных
        if (audioData.byteLength === 0) {
          log("Аудио данные имеют нулевую длину", "warn");
          return;
        }
        
        log(`Получено ${audioData.byteLength} байт аудио данных`);
        
        // Предполагаем, что данные в формате PCM16, конвертируем в WAV для воспроизведения
        const wavBuffer = createWavFromPcm(audioData);
        const blob = new Blob([wavBuffer], { type: 'audio/wav' });
        const audioUrl = URL.createObjectURL(blob);
        
        // Воспроизводим звук
        const audio = new Audio(audioUrl);
        audio.onerror = function(e) {
          log(`Ошибка воспроизведения аудио: ${e.target.error.message || 'Неизвестная ошибка'}`, "error");
        };
        
        audio.oncanplaythrough = function() {
          log(`Готов к воспроизведению аудио: ${audio.duration.toFixed(2)} секунд`);
          audio.play().catch(err => {
            log(`Ошибка при воспроизведении: ${err.message}`, "error");
          });
        };
        
        // Освобождаем ресурсы после воспроизведения
        audio.onended = function() {
          URL.revokeObjectURL(audioUrl);
        };
      } catch (error) {
        log(`Ошибка воспроизведения аудио: ${error.message}`, "error");
      }
    }
    
    // Добавление сообщения в чат
    function addMessage(text, isUser) {
      const messageElement = document.createElement('div');
      messageElement.className = `message ${isUser ? 'user-message' : 'assistant-message'}`;
      messageElement.textContent = text;
      messagesContainer.appendChild(messageElement);
      messagesContainer.scrollTop = messagesContainer.scrollHeight;
    }
    
    // Подключение к WebSocket серверу (локальный прокси)
    async function connectWebSocket() {
      return new Promise((resolve, reject) => {
        try {
          loadingModal.classList.add('active');
          statusElement.textContent = "Подключение...";
          log("Подключение к WebSocket серверу...");
          
          // Используем WebSocket-соединение с нашим локальным прокси
          const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
          const wsUrl = `${protocol}//${window.location.host}/ws`;
          log(`WebSocket URL: ${wsUrl}`);
          
          // Создаем новое WebSocket соединение
          websocket = new WebSocket(wsUrl);
          
          // Устанавливаем таймаут на открытие соединения
          const connectionTimeout = setTimeout(() => {
            log("Превышено время ожидания соединения WebSocket", "error");
            websocket.close();
            reject(new Error("Таймаут соединения"));
          }, 15000);
          
          websocket.onopen = function() {
            clearTimeout(connectionTimeout);
            log("WebSocket соединение установлено");
            statusElement.textContent = "Подключено";
            statusElement.style.color = "#4a86e8";
            isConnected = true;
            loadingModal.classList.remove('active');
            
            // Обновляем сессию с выбранным голосом
            updateSessionSettings();
            
            // Если настройка "всегда слушать" включена, начинаем слушать
            if (userSettings.alwaysListen) {
              startListening();
            }
            
            resolve(true);
          };
          
          websocket.onmessage = function(event) {
            handleWebSocketMessage(event.data);
          };
          
          websocket.onclose = function(event) {
            log(`WebSocket соединение закрыто: код ${event.code}, причина: ${event.reason || 'не указана'}`, event.wasClean ? "info" : "error");
            statusElement.textContent = `Соединение закрыто: ${event.reason || 'Неизвестная причина'}`;
            statusElement.style.color = "#f44336";
            isConnected = false;
            
            // Пытаемся переподключиться, если соединение было разорвано не чисто
            if (!event.wasClean) {
              log(`Попытка переподключения через 3 секунды...`, "warn");
              
              setTimeout(() => {
                connectWebSocket().catch(err => {
                  log(`Ошибка при переподключении: ${err.message}`, "error");
                });
              }, 3000);
            }
            
            reject(new Error(`Соединение закрыто: ${event.reason || 'Неизвестная причина'}`));
          };
          
          websocket.onerror = function(error) {
            log(`WebSocket ошибка: ${error.message || 'Неизвестная ошибка'}`, "error");
            statusElement.textContent = "Ошибка соединения";
            statusElement.style.color = "#f44336";
            isConnected = false;
            reject(error);
          };
        } catch (error) {
          log(`Ошибка при установке WebSocket соединения: ${error.message}`, "error");
          reject(error);
        }
      });
    }
    
    // Обновление настроек сессии на сервере
    function updateSessionSettings() {
      if (!isConnected || !websocket || websocket.readyState !== WebSocket.OPEN) {
        log("Невозможно обновить настройки: нет соединения", "warn");
        return;
      }
      
      try {
        log(`Обновление настроек сессии. Голос: ${userSettings.voice}`);
        
        // Отправляем обновление настроек
        const updateMessage = {
          type: "session.update",
          event_id: `settings_${Date.now()}`,
          session: {
            voice: userSettings.voice
          }
        };
        
        websocket.send(JSON.stringify(updateMessage));
      } catch (error) {
        log(`Ошибка при обновлении настроек: ${error.message}`, "error");
      }
    }
    
    // Обработка сообщений от сервера
    function handleWebSocketMessage(data) {
      try {
        // Если данные в бинарном формате, преобразуем их в текст
        if (data instanceof Blob) {
          const reader = new FileReader();
          reader.onload = function() {
            const text = reader.result;
            try {
              const json = JSON.parse(text);
              processServerEvent(json);
            } catch (e) {
              log(`Ошибка парсинга JSON из бинарных данных: ${e.message}`, "error");
            }
          };
          reader.readAsText(data);
        } else {
          try {
            const json = typeof data === 'string' ? JSON.parse(data) : data;
            processServerEvent(json);
          } catch (e) {
            log(`Ошибка парсинга JSON из текстовых данных: ${e.message}`, "error");
            log(`Данные: ${typeof data === 'string' ? data.substring(0, 100) : 'не строка'}`, "debug");
          }
        }
      } catch (error) {
        log(`Ошибка обработки сообщения: ${error.message}`, "error");
      }
    }
    
    // Обработка событий от сервера
    let currentResponseText = "";
    let lastAudioTimestamp = 0;
    let currentResponseId = null;
    let currentItemId = null;
    const audioChunks = [];
    
    function processServerEvent(event) {
      if (!event || !event.type) {
        log("Получено некорректное событие без типа", "warn");
        return;
      }
      
      log(`Событие от сервера: ${event.type}`, "debug");
      
      // Сохраняем ID текущего ответа и элемента, если они есть
      if (event.response_id && !currentResponseId) {
        currentResponseId = event.response_id;
      }
      
      if (event.item_id && !currentItemId) {
        currentItemId = event.item_id;
      }
      
      switch (event.type) {
        case "error":
          log(`Ошибка от сервера: ${event.error ? event.error.message : 'Неизвестная ошибка'}`, "error");
          statusElement.textContent = `Ошибка: ${event.error ? event.error.message : 'Неизвестная ошибка'}`;
          
          // Анимируем круг, чтобы показать ошибку
          mainCircle.style.boxShadow = "0 0 20px rgba(244, 67, 54, 0.5)";
          setTimeout(() => {
            mainCircle.style.boxShadow = "";
          }, 2000);
          break;
          
        case "conversation.item.input_audio_transcription.delta":
        case "conversation.item.input_audio_transcription.completed":
          // Обновляем транскрипцию распознанной речи пользователя
          if (event.transcript || event.delta) {
            const transcript = event.transcript || event.delta;
            transcriptElement.textContent = transcript;
            log(`Транскрипция: ${transcript}`, "info");
            
            if (event.type === "conversation.item.input_audio_transcription.completed") {
              addMessage(transcript, true);
              transcriptElement.textContent = "";
            }
          }
          break;
          
        case "response.text.delta":
          // Обрабатываем текстовый ответ по частям
          if (event.delta) {
            currentResponseText += event.delta;
            
            // Обновляем текущее сообщение или создаем новое
            const lastMessage = messagesContainer.lastElementChild;
            if (lastMessage && lastMessage.classList.contains('assistant-message') && 
                lastMessage !== messagesContainer.firstElementChild) {
              lastMessage.textContent = currentResponseText;
            } else {
              addMessage(currentResponseText, false);
            }
            
            // Анимируем круг, показывая активность
            mainCircle.style.boxShadow = "0 0 30px rgba(74, 134, 232, 0.3)";
          }
          break;
          
        case "response.text.done":
          // Текстовый ответ завершен
          if (event.text) {
            currentResponseText = event.text;
            log(`Текстовый ответ завершен: ${currentResponseText.substring(0, 50)}...`, "info");
            
            // Обновляем текущее сообщение или создаем новое
            const lastMessage = messagesContainer.lastElementChild;
            if (lastMessage && lastMessage.classList.contains('assistant-message') && 
                lastMessage !== messagesContainer.firstElementChild) {
              lastMessage.textContent = currentResponseText;
            } else {
              addMessage(currentResponseText, false);
            }
            
            // Сбрасываем анимацию круга
            setTimeout(() => {
              mainCircle.style.boxShadow = "";
            }, 1000);
          }
          break;
          
        case "response.audio.delta":
          // Обрабатываем аудиоответ по частям
          if (event.delta) {
            audioChunks.push(event.delta);
            log(`Получен фрагмент аудио: ${event.delta.length} символов`, "debug");
          }
          break;
          
        case "response.audio.done":
          // Аудиоответ завершен, воспроизводим его
          if (audioChunks.length > 0) {
            log(`Аудиоответ завершен, ${audioChunks.length} фрагментов`, "info");
            const fullAudio = audioChunks.join('');
            // Дамп первых 100 символов для отладки
            if (fullAudio.length > 0) {
              log(`Аудио данные (первые 50 символов): ${fullAudio.substring(0, 50)}...`, "debug");
            }
            playAudio(fullAudio);
            audioChunks.length = 0; // Очищаем массив
          }
          break;
          
        case "response.done":
          // Ответ полностью завершен
          log("Ответ полностью завершен", "info");
          isProcessing = false;
          
          // Сбрасываем состояние
          currentResponseText = "";
          audioChunks.length = 0;
          currentResponseId = null;
          currentItemId = null;
          resetAudioVisualization();
          
          // Сбрасываем эффекты UI
          mainCircle.style.boxShadow = "";
          
          // Если настройка "всегда слушать" включена, начинаем слушать снова
          if (userSettings.alwaysListen && !isListening) {
            startListening();
          }
          
          // Активируем кнопки
          voiceButton.disabled = false;
          textInput.disabled = false;
          break;
          
        case "session.created":
          log("Сессия создана на сервере", "info");
          break;
          
        case "session.updated":
          log("Сессия обновлена", "info");
          
          // Если в ответе есть информация о голосе, обновляем настройки
          if (event.session && event.session.voice) {
            log(`Голос обновлен на: ${event.session.voice}`, "info");
          }
          break;
          
        case "input_audio_buffer.committed":
          log("Аудиобуфер отправлен", "info");
          break;
          
        case "input_audio_buffer.cleared":
          log("Аудиобуфер очищен", "info");
          break;
          
        case "input_audio_buffer.speech_started":
          log("Обнаружена речь", "info");
          // Анимируем круг, показывая обнаружение речи
          mainCircle.style.boxShadow = "0 0 30px rgba(244, 67, 54, 0.3)";
          break;
          
        case "input_audio_buffer.speech_stopped":
          log("Речь завершена", "info");
          // Сбрасываем анимацию круга
          setTimeout(() => {
            mainCircle.style.boxShadow = "";
          }, 500);
          break;
          
        default:
          log(`Неизвестный тип события: ${event.type}`, "debug");
      }
    }
    
    // Начало записи голоса
    function startListening() {
      if (!isConnected || isProcessing) {
        log("Невозможно начать запись: " + (!isConnected ? "не подключено" : "идет обработка"), "warn");
        return;
      }
      
      isListening = true;
      isProcessing = false;
      voiceButton.classList.add('listening');
      transcriptElement.textContent = "Говорите...";
      log("Начало записи голоса", "info");
      
      // Отправляем команду для очистки буфера ввода
      if (websocket && websocket.readyState === WebSocket.OPEN) {
        websocket.send(JSON.stringify({
          type: "input_audio_buffer.clear",
          event_id: `clear_${Date.now()}`
        }));
      }
      
      // Возобновляем AudioContext если он был приостановлен
      if (audioContext && audioContext.state === 'suspended') {
        audioContext.resume();
      }
      
      // Анимируем круг, показывая запись
      mainCircle.style.boxShadow = "0 0 30px rgba(74, 134, 232, 0.2)";
    }
    
    // Окончание записи голоса
    function stopListening() {
      if (!isListening) return;
      
      isListening = false;
      voiceButton.classList.remove('listening');
      transcriptElement.textContent = "Обработка...";
      log("Завершение записи голоса", "info");
      
      // Отправляем команду для завершения записи
      if (websocket && websocket.readyState === WebSocket.OPEN) {
        websocket.send(JSON.stringify({
          type: "input_audio_buffer.commit",
          event_id: `commit_${Date.now()}`
        }));
        
        // Отправляем команду для создания ответа
        websocket.send(JSON.stringify({
          type: "response.create",
          event_id: `response_${Date.now()}`,
          response: {}
        }));
      }
      
      isProcessing = true;
      resetAudioVisualization();
      
      // Деактивируем кнопки на время обработки
      voiceButton.disabled = true;
      textInput.disabled = true;
    }
    
    // Отправка текстового сообщения
    function sendTextMessage() {
      if (!isConnected || isProcessing) {
        log("Невозможно отправить сообщение: " + (!isConnected ? "не подключено" : "идет обработка"), "warn");
        return;
      }
      
      const text = textInput.value.trim();
      if (!text) {
        log("Попытка отправить пустое сообщение", "warn");
        return;
      }
      
      log(`Отправка текстового сообщения: ${text}`, "info");
      
      // Добавляем сообщение пользователя в чат
      addMessage(text, true);
      
      // Отправляем сообщение через WebSocket
      websocket.send(JSON.stringify({
        type: "conversation.item.create",
        event_id: `msg_${Date.now()}`,
        item: {
          type: "message",
          role: "user",
          content: [
            {
              type: "input_text",
              text: text
            }
          ]
        }
      }));
      
      // Отправляем команду для создания ответа
      websocket.send(JSON.stringify({
        type: "response.create",
        event_id: `response_${Date.now()}`,
        response: {}
      }));
      
      // Сбрасываем поле ввода и состояние
      textInput.value = "";
      isProcessing = true;
      
      // Если был режим слушания, останавливаем его
      if (isListening) {
        stopListening();
      }
      
      // Деактивируем кнопки на время обработки
      voiceButton.disabled = true;
      textInput.disabled = true;
    }
    
    // Открытие модального окна настроек
    function openSettingsModal() {
      // Устанавливаем текущие значения в элементы формы
      voiceSelector.value = userSettings.voice;
      alwaysListenToggle.checked = userSettings.alwaysListen;
      
      // Отображаем модальное окно
      settingsModal.classList.add('active');
    }
    
    // Закрытие модального окна настроек без сохранения
    function closeSettingsModal() {
      settingsModal.classList.remove('active');
    }
    
    // Сохранение настроек
    function saveSettings() {
      // Получаем значения из формы
      const newVoice = voiceSelector.value;
      const newAlwaysListen = alwaysListenToggle.checked;
      
      // Проверяем, изменился ли голос
      const voiceChanged = newVoice !== userSettings.voice;
      const listenModeChanged = newAlwaysListen !== userSettings.alwaysListen;
      
      // Сохраняем новые настройки
      userSettings.voice = newVoice;
      userSettings.alwaysListen = newAlwaysListen;
      
      log(`Настройки сохранены: голос=${newVoice}, всегдаСлушать=${newAlwaysListen}`, "info");
      
      // Если голос изменился и есть соединение, обновляем настройки на сервере
      if (voiceChanged && isConnected) {
        updateSessionSettings();
      }
      
      // Если изменился режим прослушивания
      if (listenModeChanged) {
        if (newAlwaysListen && !isListening && !isProcessing) {
          // Если включили режим "всегда слушать" и не слушаем сейчас, начинаем слушать
          startListening();
        } else if (!newAlwaysListen && isListening && !isProcessing) {
          // Если выключили режим "всегда слушать" и слушаем сейчас, останавливаем
          stopListening();
        }
      }
      
      // Закрываем модальное окно
      closeSettingsModal();
    }
    
    // Инициализация всего приложения
    async function init() {
      try {
        log("Инициализация приложения", "info");
        
        // Настраиваем обработчики событий для настроек
        settingsButton.addEventListener('click', openSettingsModal);
        settingsCancel.addEventListener('click', closeSettingsModal);
        settingsSave.addEventListener('click', saveSettings);
        
        // Обработчик для большого активационного круга
        activationButton.addEventListener('click', () => {
          if (isProcessing) return;
          
          if (isListening) {
            stopListening();
          } else {
            startListening();
          }
        });
        
        // Инициализируем аудио
        const audioInitialized = await initAudio();
        
        if (audioInitialized) {
          log("Аудио инициализировано успешно", "info");
          
          // Подключаемся к WebSocket серверу
          const connected = await connectWebSocket();
          
          if (connected) {
            log("Подключение к WebSocket установлено", "info");
            
            // Обработчики событий UI
            voiceButton.addEventListener('click', event => {
              event.preventDefault();
              if (isProcessing) return;
              
              if (isListening) {
                stopListening();
              } else {
                startListening();
              }
            });
            
            // Для отправки текстового сообщения
            textInput.addEventListener('keypress', function(e) {
              if (e.key === 'Enter') {
                e.preventDefault();
                sendTextMessage();
              }
            });
            
            // Если пользователь щелкнул вне модального окна настроек, закрываем его
            window.addEventListener('click', function(e) {
              if (e.target === settingsModal) {
                closeSettingsModal();
              }
            });
            
            // Если страница теряет фокус, останавливаем запись
            window.addEventListener('blur', () => {
              if (isListening && !userSettings.alwaysListen) {
                log("Страница потеряла фокус, остановка записи", "info");
                stopListening();
              }
            });
            
            log("Обработчики событий установлены", "info");
          } else {
            log("Не удалось установить подключение к WebSocket", "error");
            loadingModal.classList.remove('active');
            alert("Не удалось подключиться к серверу. Проверьте консоль для получения дополнительной информации.");
          }
        } else {
          log("Не удалось инициализировать аудио", "error");
          loadingModal.classList.remove('active');
          alert("Не удалось инициализировать аудио. Пожалуйста, разрешите доступ к микрофону и перезагрузите страницу.");
        }
      } catch (error) {
        log(`Ошибка инициализации: ${error.message}`, "error");
        loadingModal.classList.remove('active');
        alert(`Произошла ошибка: ${error.message}`);
      }
    }
    
    // Запускаем инициализацию после загрузки страницы
    window.addEventListener('load', init);
    
    // Обработка ошибок на уровне окна
    window.addEventListener('error', function(event) {
      log(`Глобальная ошибка: ${event.message} в ${event.filename}:${event.lineno}`, "error");
    });
    
    // Double-click на статус для отображения отладочной информации
    statusElement.addEventListener('dblclick', function() {
      debugPanel.style.display = debugPanel.style.display === 'none' ? 'block' : 'none';
    });
  </script>
</body>
</html>
